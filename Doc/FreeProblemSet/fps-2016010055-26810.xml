<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[数字正方形]]></title>
<time_limit unit="s"><![CDATA[0]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p class="MsoNormal" align="left">
	<span style="font-size:14px;">现给定一个数</span><span style="font-size:14px;">N</span><span style="font-size:14px;">，用</span><span style="font-size:14px;">1</span><span style="font-size:14px;">到</span><span style="font-size:14px;">N^2</span><span style="font-size:14px;">这些数做一个</span><span style="font-size:14px;">N*N</span><span style="font-size:14px;">的数字正方形，正方形规律如下：</span><span></span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">当</span><span style="font-size:14px;">N=5</span><span style="font-size:14px;">时输出正方形：</span><span></span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">1 2 3 4
5</span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">16 17 18
19 6</span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">15 24 25
20 7</span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">14 23 22
21 8</span>
</p>
<p class="MsoNormal" align="left">
	<span style="font-size:14px;">13 12 11
10 9</span>
</p>]]></description>
<input><![CDATA[<p class="MsoNormal" align="left" style="text-indent:21pt;">
	测试包含多组测试数据<span>,</span>每组测试数据包含一行，
</p>
<p class="MsoNormal" align="left" style="text-indent:21pt;">
	<span style="line-height:1.5;">每行输入一个整数</span><span style="line-height:1.5;">N</span><span style="line-height:1.5;">，</span><span style="line-height:1.5;">1&lt;=N&lt;=10;</span>
</p>]]></input> 
<output><![CDATA[<p class="MsoNormal" align="left" style="text-indent:21pt;">
	对于每组测试数据输出如上规则的数字正方形
</p>
<p class="MsoNormal" align="left">
	<span></span>
</p>]]></output>
<sample_input><![CDATA[1
3]]></sample_input>
<sample_output><![CDATA[1
1 2 3
8 9 4
7 6 5]]></sample_output>
  <test_input><![CDATA[3
1
2
4
6
5
9
8
10
7]]></test_input>
<test_output><![CDATA[1 2 3
8 9 4
7 6 5
1
1 2
4 3
1 2 3 4
12 13 14 5
11 16 15 6
10 9 8 7
1 2 3 4 5 6
20 21 22 23 24 7
19 32 33 34 25 8
18 31 36 35 26 9
17 30 29 28 27 10
16 15 14 13 12 11
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
1 2 3 4 5 6 7 8 9
32 33 34 35 36 37 38 39 10
31 56 57 58 59 60 61 40 11
30 55 72 73 74 75 62 41 12
29 54 71 80 81 76 63 42 13
28 53 70 79 78 77 64 43 14
27 52 69 68 67 66 65 44 15
26 51 50 49 48 47 46 45 16
25 24 23 22 21 20 19 18 17
1 2 3 4 5 6 7 8
28 29 30 31 32 33 34 9
27 48 49 50 51 52 35 10
26 47 60 61 62 53 36 11
25 46 59 64 63 54 37 12
24 45 58 57 56 55 38 13
23 44 43 42 41 40 39 14
22 21 20 19 18 17 16 15
1 2 3 4 5 6 7 8 9 10
36 37 38 39 40 41 42 43 44 11
35 64 65 66 67 68 69 70 45 12
34 63 84 85 86 87 88 71 46 13
33 62 83 96 97 98 89 72 47 14
32 61 82 95 100 99 90 73 48 15
31 60 81 94 93 92 91 74 49 16
30 59 80 79 78 77 76 75 50 17
29 58 57 56 55 54 53 52 51 18
28 27 26 25 24 23 22 21 20 19
1 2 3 4 5 6 7
24 25 26 27 28 29 8
23 40 41 42 43 30 9
22 39 48 49 44 31 10
21 38 47 46 45 32 11
20 37 36 35 34 33 12
19 18 17 16 15 14 13]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[GZU]]></source>
		<solution language="C"><![CDATA[
#include <stdio.h>
main()
{
 int N;
 int a[10][10];
 while (scanf("%d",&N)!=EOF){
        int i,j,k,n=1;
 for(k=0;k<(N+1)/2;k++)
{ for(i=k,j=k;j<N-1-k;j++)
 {a[i][j]=n;n++;}
 for(;i<N-1-k;i++)
 {a[i][j]=n;n++;}
 for(;j>k;j--)
 {a[i][j]=n;n++;}
 for(;i>k;i--)
 {a[i][j]=n;n++;}
}
 if(N%2!=0)
 a[i][j]=n;
 for(i=0;i<N;i++)
{
 for(j=0;j<N;j++)
    if (j!=(N-1))
 printf("%d ",a[i][j]);
 else printf("%d",a[i][j]);
 if (j!=(N-1))
    printf("\n");
}
}
}
]]></solution>
			<solution language="C++"><![CDATA[#include <bits/stdc++.h>
using namespace std;
int a[15][15];
int n;

void change()
{
	int ff=0;
	int data=1;
	int i=1,j=1;
	
	while(data<=n*n){
		
		a[i][j]=data++;
		
		
		if (ff==0){
			j++;
			if (a[i][j]!=0){
				i++;
				j--;
				ff=1;
			}
			continue;
		}
		
		if (ff==1){
			
			i++;
			if (a[i][j]!=0) {
				j--;
				i--;
				ff=2;
			}
			continue;
		}
		
		if (ff==2){
			
			j--;
			if (a[i][j]!=0){
				i--;
				j++;
				ff=3;
			} 
			
			continue;
			
		}
		
		
		if (ff==3){
			i--;
			if (a[i][j]!=0){
				j++;
				i++;
				ff=0;
			}
		
			
			continue;
		}
		
	}
	
	
}

void init()
{
	memset(a,0,sizeof(a));
	for (int i=0;i<=n+1;i++){
		a[0][i]=a[i][0]=a[n+1][i]=a[i][n+1]=-1;
	}
}


void print()
{
	for (int i=1;i<=n;i++){
		for (int s=1;s<=n;s++){
			if (s>1) printf(" ");
			printf("%d",a[i][s]);
		}
		printf("\n");
	}
}

int main()
{
	
	while(~scanf("%d",&n)){
		
		init();
		
		change();
		
		print();
		
	}
	return 0;
}]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		boolean flag = true;
		int n;
		while (scan.hasNextInt()) {
			n = scan.nextInt();
			int[][] arrs = new int[n][n];
			int a;
			int b;
			int c = 0;
			int z = n * n;// 矩阵最大数字
			int ou = 1;// 当前数字
			while (ou <= z) {
				a = 0;
				b = 0;
				for (a = a + c, b = b + c; b < n - c; b++) {// 从左到右
					if (ou > z) {
						break;
					} else {
						arrs[a][b] = ou++;
					}
				}

				for (b--, a++; a < n - c; a++) {// 从上到下
					if (ou > z) {
						break;
					} else {
						arrs[a][b] = ou++;
					}
				}

				for (b--, a--; b >= c; b--) {// 从右到左
					if (ou > z) {
						break;
					} else {
						arrs[a][b] = ou++;
					}
				}

				for (a--, b++; a >= c + 1; a--) {// 从下到上
					if (ou > z) {
						break;
					} else {
						arrs[a][b] = ou++;
					}
				}
				c++;// 圈数
			}

			int i, j;
			for (i = 0; i < n; i++) {
				for (j = 0; j < n; j++)
					System.out.print(arrs[i][j] + " ");

				System.out.println();
			}
		}
      
       
	}

}]]></solution>
	</item>
</fps>
