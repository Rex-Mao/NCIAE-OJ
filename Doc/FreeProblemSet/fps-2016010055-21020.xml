<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[摆花]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共m盆。通过调查顾客的喜好，小明列出了顾客最喜欢的n种花，从1到n标号。为了在门口展出更多种花，规定第i 种花不能超过a<sub>i</sub>盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。
</p>
<p>
	试编程计算，一共有多少种不同的摆花方案。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据的第一行包含两个正整数n和m，中间用一个空格隔开。
</p>
<p>
	第二行有n个整数，每两个整数之间用一个空格隔开，依次表示a<sub>1</sub>、a<sub>2</sub>、...a<sub>n</sub>。
</p>
<p>
	<br />
</p>
<p>
	数据规模：
</p>
<p>
	对于20%数据，有0&lt;n≤8，0&lt;m≤8，0≤a<sub>i</sub>≤8；
</p>
<p>
	对于50%数据，有0&lt;n≤20，0&lt;m≤20，0≤a<sub>i</sub>≤20；
</p>
<p>
	对于100%数据，有0&lt;n≤100，0&lt;m≤100，0≤a<sub>i</sub>≤100。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	每组输出只有一行，一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对1000007取模的结果。
</p>
<p>
	<br />
</p>
<p>
	下面是对样例数据的解释：
</p>
<p>
	有2种摆花的方案，分别是(1，1，1，2)，(1，1，2，2)。括号里的1和2表示两种花，比如第一个方案是前三个位置摆第一种花，第四个位置摆第二种花。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[2 4
3 2]]></sample_input>
<sample_output><![CDATA[2]]></sample_output>
  <test_input><![CDATA[20 20
1 7 5 10 1 16 8 10 16 12 4 14 16 18 0 16 13 2 5 20
]]></test_input>
<test_output><![CDATA[13203
]]></test_output>
<test_input><![CDATA[91 100
37 77 5 88 86 35 79 63 100 95 25 95 85 44 44 81 13 36 86 70 27 11 31 3 98 0 23 61 45 38 6 37 41 50 100 58 84 30 61 36 70 66 22 33 65 57 17 92 3 0 99 11 70 71 62 22 74 84 78 34 40 99 56 55 26 65 62 82 8 72 35 92 56 55 86 38 32 20 81 54 12 19 65 7 62 82 31 11 16 34 92
]]></test_input>
<test_output><![CDATA[650098
]]></test_output>
<test_input><![CDATA[87 92
39 87 32 86 8 30 15 83 3 39 30 51 34 55 43 87 25 89 64 24 58 49 18 65 92 5 20 29 39 19 7 37 44 17 86 21 81 26 88 55 5 82 75 89 73 75 77 7 53 16 20 77 39 9 59 86 20 78 58 28 30 0 0 43 35 41 82 76 21 53 73 37 45 37 52 23 85 62 88 76 92 10 3 9 84 73 13
]]></test_input>
<test_output><![CDATA[301831
]]></test_output>
<test_input><![CDATA[8 8
2 3 2 1 1 3 5 0
]]></test_input>
<test_output><![CDATA[482
]]></test_output>
<test_input><![CDATA[57 81
68 38 15 47 80 76 57 53 18 14 51 64 54 79 14 26 45 61 39 66 2 6 29 4 79 51 77 44 13 76 79 36 28 25 54 64 48 30 52 44 35 38 79 55 54 4 59 2 22 45 9 24 78 19 67 58 71
]]></test_input>
<test_output><![CDATA[820361
]]></test_output>
<test_input><![CDATA[100 100
73 8 4 15 49 58 90 25 11 23 14 74 53 91 36 50 99 45 24 30 81 54 41 13 22 69 92 81 48 49 46 34 47 67 38 34 29 59 44 20 37 19 39 19 39 87 80 88 66 8 87 88 62 80 63 0 52 84 62 59 49 68 40 11 54 75 82 51 30 82 44 15 38 99 82 91 73 54 100 88 63 39 71 84 64 16 39 45 82 78 85 39 86 75 39 40 93 69 37 43
]]></test_input>
<test_output><![CDATA[589513
]]></test_output>
<test_input><![CDATA[3 5
3 4 4
]]></test_input>
<test_output><![CDATA[16
]]></test_output>
<test_input><![CDATA[33 50
5 0 21 40 13 7 23 7 28 2 8 21 32 45 24 8 33 13 1 33 23 45 17 42 13 20 14 8 49 15 7 37 33
]]></test_input>
<test_output><![CDATA[854728
]]></test_output>
<test_input><![CDATA[10 13
7 4 2 4 1 10 1 1 11 7
]]></test_input>
<test_output><![CDATA[71677
]]></test_output>
<test_input><![CDATA[15 18
16 13 17 17 0 6 14 17 0 13 11 18 15 11 17
]]></test_input>
<test_output><![CDATA[99221
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组-2012年NOIP全国联赛普及组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define N 1000007
#define o 102
using namespace std;
int a[o],f[o][o];
int n,m;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	
	f[0][0]=1;
	
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=a[i];k++)
			{
				if(j-k>=0) f[i][j]=(f[i][j]+f[i-1][j-k])%N;
				else break;
			}
		}
	}
	cout<<f[n][m];
	return 0;
	
}]]></solution>
			<solution language="Pascal"><![CDATA[var a:array[0..100,0..100]of longint;
    i,j,k,m,n,s,t:longint; w:array[0..100]of longint;
begin
  readln(n,m);
  for i:=1 to n do read(w[i]); 
  for i:=1 to w[1] do a[1,i]:=1; 
  for i:=0 to m do a[i,0]:=1;
  for i:=2 to m do
    for j:=1 to m do
      begin
        s:=0;
        for k:=j-w[i] to j  do
          if k>=0 then s:=(s+a[i-1,k]) mod 1000007;
        a[i,j]:=s;
      end;
  writeln(a[n,m]);
end.]]></solution>
	</item>
</fps>
