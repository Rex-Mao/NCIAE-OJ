<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[FBI树]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。<br />
<p>
	<span style="line-height:1.5;">FBI树是一种二叉树（如下图），它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：</span>
</p>
<p>
	1) T的根结点为R，其类型与串S的类型相同；
</p>
<p>
	2) 若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。
</p>
现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。<br />
<div>
	<br />
</div>]]></description>
<input><![CDATA[<p>
	每组输入数据的第一行是一个整数N（0&lt;=N&lt;=10），第二行是一个长度为2N的“01”串。
</p>
<p>
	<br />
</p>
<p>
	数据规模：<br />
对于40%的数据，N&lt;=2；<br />
对于全部的数据，N&lt;=10。<br />
	<div>
		<br />
	</div>
</p>]]></input> 
<output><![CDATA[<p>
	每组输出包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[3
10001011]]></sample_input>
<sample_output><![CDATA[IBFBBBFIBFIIIFF]]></sample_output>
  <test_input><![CDATA[0
0
]]></test_input>
<test_output><![CDATA[B
]]></test_output>
<test_input><![CDATA[1
10
]]></test_input>
<test_output><![CDATA[IBF
]]></test_output>
<test_input><![CDATA[2
1011
]]></test_input>
<test_output><![CDATA[IBFIIIF
]]></test_output>
<test_input><![CDATA[9
11000110111000000001110011110011011100011100010000110000110000000111010001010101000000111011001111100010000101101000011011111110010110000011001011011001011111100101000011011000001001001101100100011111001011000111111000110001000100111000010011101010000001101101011010101001011111100000110111001101110111110110111010100101001101001110110001100111000010000111001000100101001110111011101111100010001001100010000100110100100110010010000110101000101001100101001011011101110101111100000100111010110001001110001011001000
]]></test_input>
<test_output><![CDATA[IIIBBBFBIFIBFFFIIIIBFFBBBBBBBFFBBBBIFFIIIBBBFFIIIIIIIBBBIIIFFFFBIFIIIFBBBBIFFFIIIBBBFBIFBBBFFFBBBIIIFBBBBBBBFIIIBBBFBBBBBBBFFFFBIFIIIFBIFBBBFFBIFBIFFBIFBIFFFFBBBBBBBBBBIIIFFIBFIIIFBBBIIIFFFFIIIIBFFBBBIBFFFBBBBIFFBIFIBFFFFIBFBBBFBIFIBFFFIIIIIIIIIIIBFFFFFFFBIFBIFFIBFBBBFFBBBIIIFBBBIBFFFFIIIBIFFIBFBIFFFBIFIIIFIIIIBFFFFFBIFBIFFBBBBBBBFIIIBIFFIBFBBBFFFBBBIBFFBIFBBBFFIIIBIFFIBFBIFFFFFFBBBBIFFIIIIIIIFBBBIBFFIIIBBBFFFBIFIIIFIIIIBFFFBBBIIIFBBBBIFFFFFBBBBIFFBBBIIIFFIBFBBBFBIFBBBFFFIIIIBFFIBFIBFFFBBBBBBBBIFIBFFFFFFFFIIIBIFFBIFIBFFFIBFIBFFIBFBIFFFFBIFIIIFIIIIBFFFBBBBBBBIIIBIFFFFFIIIBBBFIIIBIFFFIIIBIFFIIIIIIIFFBIFIBFFIIIIBFFFIBFIBFFBIFBIFFFFFFBBBIIIFBIFBBBFFIIIIBFFIIIBBBFFFBIFIBFFBIFIIIFFBBBBBBBIBFBBBFFFFBIFIIIFBBBIBFFFBBBIBFFBIFBIFFFFBBBIIIFIBFIIIFFIBFIIIFIBFIIIFFFFFFIIIIBFFBBBIBFFFBBBIBFFBIFIBFFFFBBBIBFFBBBBIFFFBBBIIIFBIFBBBFFFFIBFBIFFIBFBIFFFBBBIBFFBBBBIFFFFIBFIBFFIBFBBBFFIBFIBFFBIFIBFFFFFFBIFBIFFBBBIBFFFIIIBIFFIIIBIFFFFIIIBIFFBIFIIIFFIIIBBBFBBBBIFFFFFBBBIIIFIBFIBFFFIIIBBBFBIFBBBFFFIIIIBFFBBBIBFFFIIIBBBFIBFBBBFFFFFFFF
]]></test_output>
<test_input><![CDATA[2
0101
]]></test_input>
<test_output><![CDATA[BIFBIFF
]]></test_output>
<test_input><![CDATA[5
10100100111010000000001011001100
]]></test_input>
<test_output><![CDATA[IBFIBFFBIFBBBFFIIIIBFFIBFBBBFFFBBBBBBBBBBIBFFFIIIBBBFIIIBBBFFFF
]]></test_output>
<test_input><![CDATA[3
10001011
]]></test_input>
<test_output><![CDATA[IBFBBBFIBFIIIFF
]]></test_output>
<test_input><![CDATA[3
11011000
]]></test_input>
<test_output><![CDATA[IIIBIFFIBFBBBFF
]]></test_output>
<test_input><![CDATA[10
1110001000011001011010111110110101001100101011001110010001010001110111111000111010011010110001100000010010001100000000101100110010110001110010101000011000011011110011000001010110111010100000001010010001101011000111010100011100000101100111111100011111001010100000000011001100010101111101001111111100000000000000111101110001111010011101011100110000111010111101000100110111110001000010101011110111011001100000010000010001100010010100111011101001000110010001010010110111001000110100001001001100011110111101001100010111100111111100110011101100101010011010101111010101111111100101101011101001101100000110110101001010000001000010010100110100110101000010000111100110011001111001001111110000111010001000100110100001110110000110100100101010101100010101111110001101001110011111100111111000001000000000001110010101101000100001001010000001001011100100000001101111000001110101011010100011111110111110011001110100101001010000100011110001001111111011101101110001110110111101001110010011001110000100111100010000001011001100000011001001000101
]]></test_input>
<test_output><![CDATA[IIIIBFFBBBIBFFFBBBBIFFIBFBIFFFFBIFIBFFIBFIIIFFIIIIBFFIIIBIFFFFFBIFBBBFIIIBBBFFIBFIBFFIIIBBBFFFIIIIBFFBIFBBBFFBIFBIFFBBBBIFFFFFFIIIBIFFIIIIIIIFIBFBBBFIIIIBFFFFIBFBIFFIBFIBFFFIIIBBBFBIFIBFFFFFBBBBBBBBIFBBBFFIBFBBBFIIIBBBFFFBBBBBBBBBBIBFFFIIIBBBFIIIBBBFFFFFFIBFIIIFBBBBIFFFIIIBBBFIBFIBFFFFIBFBBBFBIFIBFFFBBBBIFFIBFIIIFFFFIIIBBBFIIIBBBFFBBBBIFFBIFBIFFFFIBFIIIFIBFIBFFFIBFBBBFBBBBBBBFFFFIBFIBFFBIFBBBFFBIFIBFFIBFIIIFFFBBBBIFFIIIBIFFFBIFBBBFBIFIIIFFFFBBBBBBBBIFBIFFFIBFBIFFIIIIIIIFFIIIBBBFBIFIIIFFIIIBBBFIBFIBFFFFFFFFIBFBBBFBBBBBBBFBBBIIIFBBBIIIFFFBBBBIFFBIFBIFFFIIIIIIIBIFBBBFFFFIIIIIIIIIIIIIIIBBBBBBBBBBBBBBBFBBBBBBBBBBIIIFFIIIBIFFIIIBBBFFFFFBIFIIIFIBFIBFFFBIFIIIFBIFBIFFFFIIIBBBFIIIBBBFFBBBIIIFIBFIBFFFFFIIIIIIIBIFBBBFFBIFBBBFIIIBIFFFFIIIIIIIBBBBIFFFBBBBBBBIBFIBFFFFFFFIBFIIIFIIIBIFFFIIIBIFFIBFBIFFFFIBFBBBFBBBBIFFFBBBBBBBBIFBBBFFFFBIFIBFFBBBIBFFFBIFBIFFBBBIIIFFFIBFIIIFIBFIBFFFBIFBBBFBIFIBFFFFFFBIFBBBFBIFBIFFFBBBIBFFIIIBIFFFFIIIBBBFIBFBBBFFIIIBIFFBBBBBBBFFFIBFBIFFBBBIIIFFBBBBIFFIIIIBFFFFIIIIIIIBIFBBBFFIIIBBBFBIFBIFFFFFFFFFIIIIBFFBIFIIIFFIIIIIIIBBBIIIFFFBBBIIIFIBFIIIFFBBBIBFFIBFIBFFFFFBIFIBFFIBFIBFFFIIIIIIIBIFBIFFFFBIFIIIFIIIIIIIFIBFBIFFBIFIBFFFFFFIBFIIIFIBFIBFFFBIFIBFFIIIBBBFFFBBBBIFFIBFIIIFFBIFBIFFBBBIBFFFFFIBFBBBFBBBBIFFFBBBBBBBIBFBIFFFFBIFBBBFIIIBIFFFBBBIIIFBIFBIFFFFFFFBBBBBBBIBFBBBFFBIFIIIFIBFBIFFFFIBFBIFFIBFBIFFFIIIIBFFBIFBBBFFFFIIIIIIIIIIBBBFFBBBIIIFIBFIBFFFFBBBIBFFBBBIBFFFBIFIBFFIBFBBBFFFFFBIFIIIFBIFIBFFFBBBBIFFIBFIBFFFFBIFBBBFIBFIBFFFIBFIBFFIIIBBBFFFFBIFBIFFBIFIIIFFIIIIBFFBBBIIIFFFBIFBBBFIIIIBFFFBIFIIIFIIIIBFFFFFFFFBIFIIIFIIIIBFFFBBBBBBBIBFBBBFFFBBBBBBBBBBBBBBBIIIIBFFBIFBIFFFFFBIFIBFFIBFBBBFFIBFBBBFBIFBBBFFFIBFIBFFBBBBBBBFBIFBBBFIBFIIIFFFFFIBFBIFFBBBBBBBFBBBBIFFIBFIIIFFFIIIBBBFBBBBIFFFIIIBIFFBIFBIFFFFFIBFIBFFIBFBBBFFIIIIIIIIIIIBFFFFIIIIIIIIBFBIFFFIBFBIFFIIIBIFFFFFFFBBBIBFFIBFBIFFFBIFBBBFBBBIBFFFFBBBIIIFIIIBBBFFBIFBBBFIIIIIIIFFFIIIIBFFIIIIBFFFIIIBIFFIIIBBBFFFBIFIIIFBIFIBFFFIIIIIIIBIFBBBFFFFFIIIIBFFBIFBBBFFIIIBBBFIIIIBFFFFBBBBIFFBBBIIIFFIIIBBBFBIFBBBFFFFBBBBBBBIBFIIIFFBBBIIIFBBBBBBBFFBBBIIIFBBBIBFFFBIFBBBFBIFBIFFFFFFFFFF
]]></test_output>
<test_input><![CDATA[6
0110101101011001011110000100100101011011100111111010001000100100
]]></test_input>
<test_output><![CDATA[BIFIBFFIBFIIIFFBIFBIFFIBFBIFFFFBIFIIIFIBFBBBFFBIFBBBFIBFBIFFFFFBIFBIFFIBFIIIFFIBFBIFFIIIIIIIFFIBFIBFFBBBIBFFFBBBIBFFBIFBBBFFFFF
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组-2004年NOIP全国联赛普及组]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
#include <math.h>
struct list
{
	int left;
	int data;
	char ch;
   int right;
	};
struct list tree[2050];

void print(int root)
{
	if(root!=-1)
	  {
		  print(tree[root].left);
		  print(tree[root].right);
		  printf("%c",tree[root].ch);
		  }
	}
main()
{
	
	int i=1,n;
	//FILE *fin=fopen("fbi.in","r");
	scanf("%d",&n);
	int front,len,node;
	front=pow(2,n);
	len=pow(2,n+1);
	node=pow(2,n-1);
	  
	
	
	for(i=front;i<len;i++)
	 {
		 scanf("%1d",&tree[i].data);
		 tree[i].left=-1;
		 tree[i].right=-1;
		 if(tree[i].data==1)
		   tree[i].ch='I';
		 else
		   tree[i].ch='B';
		 }
		/*for(i=1;i<len;i++)
		 printf("%c ",tree[i].ch);
		 printf("\n");*/
    int temp=n-1;
    while(temp>=0)
      {
	      for(i=pow(2,temp);i<pow(2,temp+1);i++)
	        {
		        tree[i].left=2*i;
		        tree[i].right=2*i+1;
		        if(tree[2*i].ch=='B' && tree[2*i+1].ch=='B')
		        tree[i].ch='B';
		        else if(tree[2*i].ch=='I' && tree[2*i+1].ch=='I')
		        tree[i].ch='I';
		        else tree[i].ch='F';
		        }
	      temp--;
	      }
	   print(1);
	  
	}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int m;
char str[3333];
char put[3] = {'B', 'I' ,'F'};
int dfs(int sx,int ex)
{
    int a,b;
    if(sx==ex)
    {
        printf("%c", put[str[sx] - '0']);
        return str[sx] - '0';
    }
    a=dfs(sx,(sx+ex)/2);
    b=dfs((ex+sx)/2+1,ex);
    if(a == b)
        {
        printf("%c", put[a]);
        return a;
        }
    else
        {
        cout<<'F';
       return 2;
       }
}
int main()
{
    scanf("%d",&m);
    scanf("%s",str);
    dfs(0,strlen(str)-1);
    cout<<endl;
    return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[var
   n,i,j:longint;
   s:ansistring;
   a:array[0..100]of longint;
   p:array[0..2050,0..2050]of char;
   f:array[0..2050,0..2050]of boolean;
procedure dfs(t,x:longint);
var
   i:longint;
begin
 if t>n+1 then exit;
 for i:=x to a[t] do
  begin
   if p[t,i]=' ' then exit;
   if f[t,i] then continue;
   write(p[t,i]);f[t,i]:=true;
   if i mod 2=0 then
    begin
     if p[t,i]=p[t,i-1]then p[t+1,i div 2]:=p[t,i] else p[t+1,i div 2]:='F';
     dfs(t+1,i div 2);
    end;
  end;
end;
begin
 readln(n);
 a[n+1]:=1;
 for i:=n downto 1 do a[i]:=a[i+1]*2;
 for i:=1 to a[1] do
  for j:=1 to n do p[j,i]:=' ';
 readln(s);
 for i:=1 to a[1] do
  if s[i]='1' then p[1,i]:='I' else p[1,i]:='B';
 dfs(1,1);
end.]]></solution>
	</item>
</fps>
