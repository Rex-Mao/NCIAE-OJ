<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[加分二叉树]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	设一个n个节点的二叉树tree的中序遍历为（l，2，3，...，n），其中数字1，2，3，...，n为节点编号。每个节点都有一个分数（均为正整数），记第j个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：
</p>
<p>
	&nbsp; &nbsp; subtree的左子树的加分×subtree的右子树的加分＋subtree的根的分数
</p>
<p>
	&nbsp; &nbsp; 若某个子树为主，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。
</p>
试求一棵符合中序遍历为（1，2，3，...，n）且加分最高的二叉树tree。要求输出：<br />
&nbsp; &nbsp; （1）tree的最高加分<br />
&nbsp; &nbsp; （2）tree的前序遍历<br />
<div>
	<br />
</div>]]></description>
<input><![CDATA[第1行：一个整数n（n＜30），为节点个数。<br />
第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。<br />
<div>
	<br />
</div>]]></input> 
<output><![CDATA[第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。<br />
第2行：n个用空格隔开的整数，为该树的前序遍历。<br />
<div>
	<br />
</div>]]></output>
<sample_input><![CDATA[5
5 7 1 2 10]]></sample_input>
<sample_output><![CDATA[145
3 1 2 4 5]]></sample_output>
  <test_input><![CDATA[10
5 4 8 9 19 2 1 40 20 22
]]></test_input>
<test_output><![CDATA[839701
7 4 2 1 3 5 6 9 8 10
]]></test_output>
<test_input><![CDATA[20
17 18 9 19 3 1 4 2 2 4 5 6 7 8 9 3 8 4 5 6
]]></test_input>
<test_output><![CDATA[317358969
5 3 1 2 4 16 12 8 6 7 10 9 11 14 13 15 18 17 19 20
]]></test_output>
<test_input><![CDATA[25
9 8 9 9 5 7 4 2 2 4 5 6 7 8 9 3 3 4 5 1 2 1 2 3 2
]]></test_input>
<test_output><![CDATA[781495238
8 4 2 1 3 6 5 7 16 12 10 9 11 14 13 15 20 18 17 19 23 21 22 24 25
]]></test_output>
<test_input><![CDATA[5
5 7 8 18 19
]]></test_input>
<test_output><![CDATA[911
4 2 1 3 5
]]></test_output>
<test_input><![CDATA[15
27 38 9 19 2 1 4 2 2 4 5 6 7 8 9
]]></test_input>
<test_output><![CDATA[6366794
5 3 1 2 4 12 8 6 7 10 9 11 14 13 15
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2003年NOIP全国联赛提高组]]></source>
		<solution language="Pascal"><![CDATA[var
   n,i,l,j,k,ans:longint;max:int64;
   a,b:array[0..100]of int64;
   f,root:array[0..100,0..100]of int64;
procedure dfs(l,r:longint);
begin
 if l>r then exit;
 inc(ans);
 b[ans]:=root[l,r];
 dfs(l,root[l,r]-1);
 dfs(root[l,r]+1,r);
end;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=1 to n do begin f[i,i]:=a[i];root[i,i]:=i;end;
 for i:=1 to n do f[i,i-1]:=1;
 for l:=1 to n-1 do
  begin
   for i:=1 to n-l do
    begin
     j:=i+l;
     max:=0;
     for k:=i to j do if f[i,k-1]*f[k+1,j]+a[k]>f[i,j]
      then begin f[i,j]:=f[i,k-1]*f[k+1,j]+a[k];root[i,j]:=k;end;
    end;
  end;
 writeln(f[1,n]);
 fillchar(b,sizeof(b),0);
 ans:=0;
 dfs(1,n);
 for i:=1 to ans-1 do write(b[i],' ');
 writeln(b[ans]);
end.]]></solution>
	</item>
</fps>
