<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[单词接龙]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和atide间不能相连。
</p>
<div>
	<br />
</div>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入的第一行为一个单独的整数n（n&lt;=20）表示单词数，以下n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。
</p>
<div>
	<br />
</div>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出以此字母开头的最长的“龙”的长度。
</p>
<p>
	下面的测试样例最后连成的“龙”为atoucheatactactouchoose。
</p>
<div>
	<br />
</div>]]></output>
<sample_input><![CDATA[5
at
touch
cheat
choose
tact
a]]></sample_input>
<sample_output><![CDATA[23]]></sample_output>
  <test_input><![CDATA[2
abababab
abababc
a
]]></test_input>
<test_output><![CDATA[19
]]></test_output>
<test_input><![CDATA[4
ABABABC
ABABABD
ABABABA
CDABABA
A
]]></test_input>
<test_output><![CDATA[43
]]></test_output>
<test_input><![CDATA[6
act
touch
cheat
choose
tact
sencitive
a
]]></test_input>
<test_output><![CDATA[31
]]></test_output>
<test_input><![CDATA[8
no
new
name
never
national
necessary
ever
me
n
]]></test_input>
<test_output><![CDATA[9
]]></test_output>
<test_input><![CDATA[6
many
youth
this
system
main
navy
m
]]></test_input>
<test_output><![CDATA[38
]]></test_output>
<test_input><![CDATA[1
envelope
e
]]></test_input>
<test_output><![CDATA[15
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2000年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,ans,num,h[25];
string s[25],st,s1;
bool Find(string A,string B)
{
	if(B.size()<=A.size())return 0;
	int C=A.size();
	for(int i=0;i<C;++i)if(B[i]!=A[i])return 0;
	return 1;
}
void work(int sum,string last)
{
	if(sum>ans){ans=sum;/*cout<<ans<<" "<<s1<<endl;*/}
	if(num==n*2)return;
	int l=last.size();
	for(int i=1;i<l;++i)
	{
	  string s2="";
	  for(int j=l-i;j<l;++j)s2+=last[j];
	  for(int j=1;j<=n;++j)
	    if(h[j]<2)
	    {
		  if(Find(s2,s[j]))
		  {
		    string s3=s1;h[j]++;
		    for(int k=i;k<s[j].size();++k)s1+=s[j][k];
		    work(sum+s[j].size()-i,s[j]);
		    s1=s3;h[j]--;
		  }
	    }
	}
}
int main()
{
	memset(h,0,sizeof(h));
	scanf("%d",&n);
	for(int i=1;i<=n;++i)cin>>s[i];
	cin>>st;
	ans=st.size();s1=st;num=0;st=" "+st;
	work(ans,st);
	printf("%d\n",ans);
	return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[Program long;
Var
   x:array[1..20]of string;
   f:array[1..20,1..20]of integer;
   start:char;
   n,i,j,k,s1,s2,min,ans:integer;
   g:array[1..20]of integer;
procedure dfs(i,p:integer);
   var j:integer;
   begin
   for j:=1 to n do
      if (g[j]<2)and(f[i,j]<>0)then
         begin
         inc(g[j]);
         dfs(j,p+f[i,j]);
         dec(g[j]);
         end;
   if p>ans then ans:=p;
   end;
Begin
readln(n);
for i:=1 to n do readln(x[i]);
for i:=1 to n do
   for j:=1 to n do
      begin
      s1:=length(x[i]);s2:=length(x[j]);
      if s1<s2 then min:=s1-1 else min:=s2-1;
      for k:=1 to min+1 do
         if (copy(x[i],s1-k+1,k)=copy(x[j],1,k)) then break;
      if k<=min then f[i,j]:=s2-k;
      end;
readln(start);
for i:=1 to n do
   if start=x[i][1] then
      begin
      fillchar(g,sizeof(g),0);
      g[i]:=1;
      dfs(i,length(x[i]));
      end;
writeln(ans);
End.]]></solution>
	</item>
</fps>
