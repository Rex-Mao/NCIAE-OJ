<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[税收与补贴问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）<br />
<span style="line-height:1.5;">对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）</span><br />
<p>
	你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。
</p>
<p>
	<br />
</p>
<p>
	<br />
</p>
<p class="MsoPlainText">
	<i><strong>总利润</strong><span><strong>&nbsp;= </strong></span><strong>单位商品利润</strong><span><strong> * </strong></span><strong>销量</strong></i> 
</p>
<p>
	<br />
</p>
<i><strong>单位商品利润 = 单位商品价格 – 单位商品成本 （– 税金&nbsp;
or&nbsp; + 补贴）</strong></i><strong></strong> 
<p>
	<br />
</p>
<p>
	<strong><br />
</strong> 
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销量售，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行-1，-1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。如在政府预期价上不能得到最大总利润，则输出"NO SOLUTION"。<br />
<div>
	<br />
</div>]]></output>
<sample_input><![CDATA[31
28 130
30 120
31 110
-1 –1
15]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <test_input><![CDATA[315
280 1300
300 1200
310 1100
-1 -1
150
]]></test_input>
<test_output><![CDATA[-32
]]></test_output>
<test_input><![CDATA[4011
1 79990
7999 10
-1 -1
10
]]></test_input>
<test_output><![CDATA[-20
]]></test_output>
<test_input><![CDATA[31
28 130
30 120
31 110
-1 -1
15
]]></test_input>
<test_output><![CDATA[4
]]></test_output>
<test_input><![CDATA[77
74 280
75 266
76 264
77 260
78 239
-1 -1
50
]]></test_input>
<test_output><![CDATA[9
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组 2000年NOIP全国联赛普及组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>

#include<cmath>

#include<algorithm>

using namespace std;

int main(){

int k,l;

int a[100000],b[100000];

int i=0;

cin>>k;

while(1){

cin>>a[i]>>b[i];

if(a[i]==-1) break;

else i++;

}

for(int j=0;j<i;j++){

int tem1,tem2;

for(int q=1;q<i-j;q++){

if(a[q-1]>a[q]){

swap(a[q-1],a[q]); swap(b[q-1],b[q]);

}

}

}

cin>>l;

int c[10000];

c[0]=b[0];

int x=1,y=a[0],z=b[0];

for(int j=1;j<i;j++){

if(a[j]!=y+1){

int p=abs(b[j]-z)/abs(a[j]-y);

int t=1;

while(y!=a[j]){

c[x++]=z-p*t;

t++;

y++;

}

           z=b[j];

}

else{

y=a[j]; z=b[j]; c[x++]=b[j];

}

}

x--; int g=1,h=c[x];

while(c[x]>0){

c[++x]=h-l*g; g++;

}

int d[10000]; int f=0;

for(int j=0;j<x;j++){

d[j]=a[0]++;

}

int e;

for(int j=0;j<x;j++) if(d[j]==k) e=c[j];

int ans1=0,ans2=0;

for(int j=0;j<100;j++){

int max; max=(k-d[0]+j)*e; int s; int flag=0;


for(int r=0;r<x;r++){

s=(d[r]-d[0]+j)*c[r];

if(s>max){

flag=1; break;

}


}

if(flag==0){

ans1=j; break;

}

}

for(int j=-1;j>-100;j--){

int max=(k-d[0]+j)*e; int s; int flag=0;

for(int r=0;r<x;r++){

s=(d[r]-d[0]+j)*c[r];

if(s>max){

flag=1; break;

}

}

if(flag==0){

ans2=j; break;

}

}

if(ans1==ans2&&ans1==0) cout<<"NO SOLUTION"<<endl;

if(ans1==0&&ans2!=0) cout<<ans2<<endl;

if(ans1!=0&&ans2==0) cout<<ans1<<endl;

if(ans1!=0&&ans2!=0&&abs(ans1)>abs(ans2)) cout<<ans2<<endl;

if(ans1!=0&&ans2!=0&&abs(ans1)<abs(ans2)) cout<<ans1<<endl;

return 0;

} ]]></solution>
			<solution language="Pascal"><![CDATA[const
  maxn=50;
  maxm=10000;
var
  d:array[1..maxm] of longint;
  price,sell:array[1..maxn] of longint;
  k1,k2:real;
c,r,t,x,y,n,each,i,j,p,most,m,u1,u2:longint;
begin
  readln(n);
  c:=0;
  repeat
    readln(x,y);
    if (x=-1)and(y=-1) then break;
    inc(c);
    price[c]:=x;
    sell[c]:=y;
  until false;
  readln(m);
  p:=price[1];
  most:=price[c]+sell[c] div m; 
  if (n<p)or(n>most) then
  begin
    writeln('NO SOLUTION');
    halt;
  end;
  for i:=1 to c-1 do
  begin
    each:=(sell[i]-sell[i+1]) div (price[i+1]-price[i]);
    for j:=price[i] to price[i+1]-1 do
      d[j]:=sell[i]-each*(j-price[i]);
  end;    
  for i:=price[c] to most do       d[i]:=sell[c]-m*(i-price[c]);
  k1:=-1e20; k2:=1e20;
  for i:=p to most do   
  begin
    r:=d[n]-d[i];
    t:=i*d[i]-n*d[n]-p*(d[i]-d[n]);
    if (r>0) and (t/r>k1) then
      k1:=t/r;
    if (r<0) and (t/r<k2) then
      k2:=t/r;
  end;
  if k1<-1e19 then u1:=-maxlongint        
  else if (k1>0)and(k1-int(k1)>0) then u1:=trunc(k1)+1 else u1:=trunc(k1);
  if k2>1e19 then u2:=maxlongint
  else if (k2<0)and(int(k2)-k2>0) then u2:=trunc(k2)-1 else u2:=trunc(k2);
 if (u1<0)and(u2>0) then
  begin
    u1:=0;
    u2:=0;
  end;
  if u1>u2 then writeln('NO SOLUTION')
  else if abs(u1)<abs(u2) then writeln(u1)
  else writeln(u2);
  readln;
end.]]></solution>
	</item>
</fps>
