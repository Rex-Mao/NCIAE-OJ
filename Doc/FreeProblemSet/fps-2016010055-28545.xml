<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[[ZJOI2008]生日聚会]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：
</p>
<p>
	对于任意连续的一段，男孩与女孩的数目之差不超过k。
</p>
<p>
	很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……
</p>
<p>
	假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。
</p>
<h2>
	输入输出格式
</h2>
<strong>输入格式：</strong><br />
<p>
	<br />
</p>
<p>
	输入文件party.in仅包含一行共3个整数，分别为男孩数目n, 女孩数目m, 常数k。
</p>
<p>
	<br />
</p>
<strong>输出格式：</strong><br />
<p>
	<br />
</p>
<p>
	输出文件party.out应包含一行，为题中要求的答案。
</p>
<p>
	<br />
</p>
<h2>
	输入输出样例
</h2>
<div class="am-g">
	<div class="am-u-md-6 copy-region">
		<strong>输入样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>1 2 1</pre>
	</div>
	<div class="am-u-md-6 copy-region">
		<strong>输出样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>1</pre>
	</div>
</div>
<h2>
	说明
</h2>
<p>
	对于30%的数据，n , m ≤ 20；
</p>
<p>
	对于100%的数据, n , m ≤ 150，k ≤ 20。
</p>
<div class="lg-article-sub am-g" id="sub">
</div>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[105 109 5
]]></test_input>
<test_output><![CDATA[5140200
]]></test_output>
<test_input><![CDATA[35 33 10
]]></test_input>
<test_output><![CDATA[7508154
]]></test_output>
<test_input><![CDATA[119 109 20
]]></test_input>
<test_output><![CDATA[6479506
]]></test_output>
<test_input><![CDATA[150 150 19
]]></test_input>
<test_output><![CDATA[10813606
]]></test_output>
<test_input><![CDATA[3 6 4
]]></test_input>
<test_output><![CDATA[59
]]></test_output>
<test_input><![CDATA[16 19 7
]]></test_input>
<test_output><![CDATA[7605713
]]></test_output>
<test_input><![CDATA[50 51 12
]]></test_input>
<test_output><![CDATA[6272549
]]></test_output>
<test_input><![CDATA[103 109 7
]]></test_input>
<test_output><![CDATA[9312796
]]></test_output>
<test_input><![CDATA[10 15 6
]]></test_input>
<test_output><![CDATA[984258
]]></test_output>
<test_input><![CDATA[150 139 10
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[ZJOI2008 省选 高级]]></source>
		<solution language="C++"><![CDATA[#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 150;
const int MAXK = 20;
const int MOD = 12345678;
int dp1[MAXN+10][MAXK+2][MAXK+2], dp2[MAXN+10][MAXK+2][MAXK+2];
int main(){
    //freopen("party.in", "r" , stdin);
    //freopen("party.out", "w", stdout);
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    int sum = n + m;
    dp1[0][0][0] = 1;
    for(int i=0;i<sum;i++){
        swap(dp1, dp2);
        memset(dp1, 0, sizeof dp1);
        for(int j=0;j<=min(i, m);j++){
            for(int k1=0;k1<=k;k1++){
                for(int k2=0;k2<=k;k2++){
                    dp1[j+1][max(k1-1, 0)][k2+1] += dp2[j][k1][k2];
                    dp1[j][k1+1][max(k2-1, 0)] += dp2[j][k1][k2];
                    dp1[j][k1][k2] %= MOD;
                }
            }
        }
    }
    int ans = 0;
    for(int k1=0;k1<=k;k1++){
        for(int k2=0;k2<=k;k2++){
            ans = (ans + dp1[m][k1][k2]) % MOD;
        }
    }
    printf("%d\n", ans);

    return 0;
}]]></solution>
	</item>
</fps>
