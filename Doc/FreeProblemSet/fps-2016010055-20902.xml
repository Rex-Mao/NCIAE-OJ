<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[联接最大数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[设有n个正整数（n≤20），将它们联接成一排，组成一个最大的多位整数。<br />
例如：n=3时，3个整数13，312，343联接成的最大整数为：34331213<br />
又如：n=4时，4个整数7，13，4，246联接成的最大整数为：7424613<br />
<br />]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入数据的第一行输入一个正整数n（<span>n≤20</span>）。
</p>
<p>
	接下来一行输入n个正整数。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出n个正整数联接成的最大的<span>多位整数。</span> 
</p>
<p>
	<span><br />
</span> 
</p>]]></output>
<sample_input><![CDATA[3
13 312 343]]></sample_input>
<sample_output><![CDATA[34331213]]></sample_output>
  <test_input><![CDATA[6
321 32 407 135 13 217
]]></test_input>
<test_output><![CDATA[4073232121713513
]]></test_output>
<test_input><![CDATA[4
1341 133 1321 37
]]></test_input>
<test_output><![CDATA[3713411331321
]]></test_output>
<test_input><![CDATA[4
13 24 75 42
]]></test_input>
<test_output><![CDATA[75422413
]]></test_output>
<test_input><![CDATA[3
121 21 3
]]></test_input>
<test_output><![CDATA[321121
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 1998年NOIP全国联赛提高组]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<string.h>
void main()
{
	int n,x,y,k,i,j;
	char b[21][15];
	scanf("%d",&n);
	for(i=0;i<n;i++)
		scanf("%s",b[i]);
	for(i=0;i<n-1;i++)
		for(j=i+1;j<n;j++)
		{
			x=strlen(b[i])>strlen(b[j])?strlen(b[j]):strlen(b[i]);
			for(k=0;k<x;k++)
			{
			    if(b[j][k]!=b[i][k])
				{
		    		if(b[j][k]>b[i][k])
					{
					    strcpy(b[20],b[j]);
		    	    	strcpy(b[j],b[i]);
			    	    strcpy(b[i],b[20]);
					}
					break;
				}
				else
					if(k==x-1&&strcmp(b[i],b[j])!=0)
					{
						if(b[i][x]=='\0')
						{
							strcpy(b[20],b[j]+x);
							for(y=i;y<n;y++)
							{
								if(strcmp(b[20],b[y])>0)
								{
									if(y==n-1)
									{
		                     	    	strcpy(b[20],b[j]);
		    	                	    strcpy(b[j],b[i]);
			                        	strcpy(b[i],b[20]);
			                	    	break;
									}
								}
								else break;
							}
						}
						else
						{
							strcpy(b[20],b[i]+x);
							for(y=i;y<n;y++)
							{
								if(strcmp(b[20],b[y])<0) 
								{
		                     	    strcpy(b[20],b[j]);
		    	                    strcpy(b[j],b[i]);
			                        strcpy(b[i],b[20]);
			                	    break;
								}
							}
						}
					}
			}
		}
	for(i=0;i<n;i++)
		printf("%s",b[i]);
}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
#include<string.h>
char a[21][100];
char c[100];
int main()
{
	int n,j,i,q,p;
	while(scanf("%d",&n)!=EOF)
	{
		getchar();
		for(i=0;i<n;i++)
			scanf("%s",a[i]);
		for(i=0;i<n-1;i++)
		{
			for(j=i+1;j<n;j++)
			{
				p=0;
				for(q=0;a[i][q]!='\0'&&a[j][q]!='\0';q++)
				{
					if(a[i][q]!=a[j][q])
					{
						p=1;
						break;
					}
				}
				if(p==1&&strcmp(a[i],a[j])<0)
					{
						strcpy(c,a[i]);
						strcpy(a[i],a[j]);
						strcpy(a[j],c);
					}
				if(strlen(a[i])>strlen(a[j]))
				{
					if(p==0&&a[i][q]<a[i][0])
					{
						strcpy(c,a[i]);
						strcpy(a[i],a[j]);
						strcpy(a[j],c);
					}
				}
				else
				{
					if(p==0&&a[j][q]>a[j][0])
					{
						strcpy(c,a[i]);
						strcpy(a[i],a[j]);
						strcpy(a[j],c);
					}
				}
			}
		}
		for(i=0;i<n;i++)
			printf("%s",a[i]);
		puts("");
	}
	return 0;
}

]]></solution>
			<solution language="Pascal"><![CDATA[var s,t:string;i,n:longint;a:array[1..20]of longint;s1:array[1..20]of string; 
procedure qsort(l,r:longint); 
var mid:string;i,j:longint; 
begin
  mid:=s1[(l+r) div 2];i:=l;j:=r; 
  repeat
    while s1[i]>mid do inc(i); 
    while s1[j]<mid do dec(j); 
    if i<=j then begin t:=s1[i];s1[i]:=s1[j];s1[j]:=t;inc(i);dec(j);end; 
  until i>j; 
  if l<j then qsort(l,j); 
  if i<r then qsort(i,r); 
end; 
begin
  read(n); 
  for i:=1 to n do
    begin
      read(a[i]); 
      str(a[i],s1[i]); 
    end; 
  qsort(1,n); 
  for i:=1 to n do
    if s1[i]+s1[i+1]<s1[i+1]+s1[i] then begin t:=s1[i]; 
                                              s1[i]:=s1[i+1]; 
                                              s1[i+1]:=t; 
                                        end; 
  for i:=1 to n do write(s1[i]); 
  writeln; 
end.]]></solution>
	</item>
</fps>
