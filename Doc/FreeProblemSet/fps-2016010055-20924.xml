<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[数的划分]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	将整数n分成k份，且每份不能为空，任意两份不能相同（不考虑顺序）。
</p>
<p>
	例如：n=7，k=3，下面三种分法被认为是相同的。
</p>
<p>
	<span style="line-height:1.5;">1，1，5；</span> 
</p>
<p>
	<span style="line-height:1.5;">1，5，1；</span> 
</p>
<p>
	<span style="line-height:1.5;">5，1，1；</span> 
</p>
<p>
	<span style="line-height:1.5;">问有多少种不同的分法。</span> 
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入两个整数n和k（<span>6&lt;n&lt;=200，2&lt;=k&lt;=6</span>）。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出<span>一个整数，即不同的分法。</span> 
</p>
<p>
	<span style="line-height:1.5;">下面是对样例数据的说明：</span> 
</p>
<p>
	样例中的四种分法是：
</p>
<p>
	1，1，5
</p>
<p>
	1，2，4
</p>
<p>
	1，3，3
</p>
<p>
	2，2，3
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[7 3]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <test_input><![CDATA[20 4
]]></test_input>
<test_output><![CDATA[64
]]></test_output>
<test_input><![CDATA[7 2
]]></test_input>
<test_output><![CDATA[3
]]></test_output>
<test_input><![CDATA[200 5
]]></test_input>
<test_output><![CDATA[583464
]]></test_output>
<test_input><![CDATA[200 6
]]></test_input>
<test_output><![CDATA[4132096
]]></test_output>
<test_input><![CDATA[100 5
]]></test_input>
<test_output><![CDATA[38225
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2001年NOIP全国联赛提高组]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
#include<string.h>
int main() 
{  
      int n,x,a[7][201],i,j;  
      while(scanf("%d%d",&n,&x)!=EOF)  
      {  
          memset(a,0,sizeof(a)); 
          for(j=0;j<=n;j++) 
              a[1][j]=1; 
          for(i=2;i<=x;i++) 
          for(j=0;j<=n-x;j++) 
          {  
              if(j>=i)  
                  a[i][j]=a[i-1][j]+a[i][j-i]; 
              else  
                  a[i][j]=a[i-1][j]; 
          }  
          printf("%d\n",a[x][n-x]); 
      }  
      return 0; 
}  ]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cstring>
using namespace std;
int count=0;
void f(int n,int x,int  mi)
{
	if (n<mi) return ;
	if (x==1 && n>=mi) count++;
	else 
	{
		int i;
		for (i=mi;i<=n/x;i++)
			f(n-i,x-1,i);
	}
}

int main()
{
	int i,n,k,max;
while (	cin>>n>>k){
count=0;
//	if (n%k==0) max=n/k-1;
	//else
	 max=n/k;
	for (i=1;i<=max;i++)
	    f(n-i,k-1,i);
	cout<<count<<endl;}
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[const
	maxn=200;
	maxk=6;
var
	n,k,i,j:longint;
	f:array[0..maxn,0..maxk] of longint;


	begin
		readln(n,k);
		f[0,0]:=1;
		for i:=1 to n do
			for j:=1 to k do
				if(i>=j)then
					f[i,j]:=f[i-j,j]+f[i-1,j-1];
		writeln(f[n,k]);
	end.
]]></solution>
	</item>
</fps>
