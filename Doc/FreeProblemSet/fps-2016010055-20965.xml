<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[能量项链]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为（Mars单位），新产生的珠子的头标记为m，尾标记为n。
</p>
<p>
	需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。
</p>
<p>
	例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：
</p>
<p>
	(4⊕1)=10*2*3=60。
</p>
<p>
	这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：
</p>
<p>
	((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。
</p>
<p>
	至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	每组输出只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[4
2 3 5 10]]></sample_input>
<sample_output><![CDATA[710]]></sample_output>
  <test_input><![CDATA[30
185 102 83 15 102 13 45 102 23 5 102 3 85 102 63 5 102 3 5 102 3 5 102 3 17 112 13 65 102 23 
]]></test_input>
<test_output><![CDATA[27221274
]]></test_output>
<test_input><![CDATA[40
205 204 202 93 5 102 43 85 102 73 85 102 83 15 102 13 45 102 23 5 102 3 85 102 3 5 102 3 5 102 3 5 102 3 17 112 13 5 102 23 
]]></test_input>
<test_output><![CDATA[56015150
]]></test_output>
<test_input><![CDATA[80
2 3 5 192 3 5 992 493 95 102 3 5 102 83 455 102 33 45 102 23 45 302 3 15 102 113 115 102 3 35 102 3 45 102 3 55 112 3 5 102 3 785 202 93 5 102 3 85 102 3 5 102 3 5 102 3 5 102 3 5 102 3 85 102 3 5 102 3 5 102 3 5 102 3 17 112 13 5 102 23 35 
]]></test_input>
<test_output><![CDATA[1940277798
]]></test_output>
<test_input><![CDATA[4
2 4 5 10
]]></test_input>
<test_output><![CDATA[780
]]></test_output>
<test_input><![CDATA[70
23 35 102 83 455 102 33 145 102 23 45 302 3 15 102 113 115 102 3 35 102 3 45 102 3 55 112 3 5 102 3 385 202 93 5 102 3 85 102 3 5 102 3 15 102 13 5 102 3 5 102 3 85 102 3 5 102 3 5 102 3 5 102 3 17 112 13 5 102 23 
]]></test_input>
<test_output><![CDATA[328479464
]]></test_output>
<test_input><![CDATA[20
402 33 85 102 63 5 102 3 75 102 3 5 102 3 17 112 113 65 102 23 
]]></test_input>
<test_output><![CDATA[54922956
]]></test_output>
<test_input><![CDATA[7
23 17 212 113 71 301 33 
]]></test_input>
<test_output><![CDATA[31182687
]]></test_output>
<test_input><![CDATA[50
202 23 45 102 43 55 112 63 65 102 3 385 202 93 5 102 3 85 102 73 85 102 83 15 102 13 45 102 23 5 102 3 85 102 3 5 102 3 5 102 3 5 102 3 17 112 13 5 102 23 
]]></test_input>
<test_output><![CDATA[129341576
]]></test_output>
<test_input><![CDATA[15
55 102 3 75 102 13 5 102 23 17 112 113 65 102 23 
]]></test_input>
<test_output><![CDATA[8950112
]]></test_output>
<test_input><![CDATA[10
113 45 102 23 17 112 113 75 101 23 
]]></test_input>
<test_output><![CDATA[7397294
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2006年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include <iostream>  
using namespace std;  
int n,e=0;  
int a[111*2];  
int dp[111*2][111*2];  
int main()  
{  
    cin>>n;  
    for(int i=1;i<=n;i++){  
      cin>>a[i];  
      a[i+n]=a[i]; 
    }  
    for(int j=2;j<=n+n;j++){  
      for(int i=j-1;i>=1&&j-i<n;i--){  
        int maxV=0;  
        for(int k=i;k<j;k++){  
          if(maxV<dp[i][k]+dp[k+1][j]+a[i]*a[k+1]*a[j+1])  
            maxV=dp[i][k]+dp[k+1][j]+a[i]*a[k+1]*a[j+1];  }  
        dp[i][j]=maxV;  
        if(e<dp[i][j])e=dp[i][j];  
      }  
    }  
    cout<<e;  
    return 0;  
} ]]></solution>
			<solution language="Pascal"><![CDATA[var
n,i,j,k:longint;
max:int64;
a:array[-10..maxint] of int64;
f:array[1..1000,1..1000] of int64;
begin


readln(n);
for i:=1 to n do
begin
read(a[i]);
a[n+i]:=a[i];
end;
for i:=2*n-1 downto 1 do
for j:=i+1 to 2*n do
for k:=i to j-1 do
if f[i,k]+f[k+1,j]+a[i]*a[k+1]*a[j+1]>f[i,j] then
begin
f[i,j]:=f[i,k]+f[k+1,j]+a[i]*a[k+1]*a[j+1] ;
if f[i,j]>max then max:=f[i,j];
end;
writeln(max div 2);


end.

]]></solution>
	</item>
</fps>
