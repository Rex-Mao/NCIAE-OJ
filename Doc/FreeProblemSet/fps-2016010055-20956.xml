<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[循环]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。
</p>
众所周知，2的正整数次幂最后一位数总是不断的在重复2，4，8，6，2，4，8，6...我们说2的正整数次幂最后一位的循环长度是4（实际上4的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：<br />
<br />
循环<br />
循环长度<br />
<br />
2<br />
2、4、8、6<br />
4<br />
<br />
3<br />
3、9、7、1<br />
4<br />
<br />
4<br />
4、6<br />
2<br />
<br />
5<br />
5<br />
1<br />
<br />
6<br />
6<br />
1<br />
<br />
7<br />
7、9、3、1<br />
4<br />
<br />
8<br />
8、4、2、6<br />
4<br />
<br />
9<br />
9、1<br />
2<br />
<br />
<p>
	这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数n的正整数次幂来说，它的后k位是否会发生循环？如果循环的话，循环长度是多少呢？
</p>
<p>
	<br />
</p>
<p>
	注意：
</p>
<p>
	1．如果n的某个正整数次幂的位数不足k，那么不足的高位看做是0。
</p>
2．如果循环长度是L，那么说明对于任意的正整数a，n的a次幂和a+L次幂的最后k位都相同。<br />
<div>
	<br />
</div>]]></description>
<input><![CDATA[<p>
	每组输入数据只有一行，包含两个整数n（1&lt;=n&lt;10100）和k（1&lt;=k&lt;=100），n和k之间用一个空格隔开，表示要求n的正整数次幂的最后k位的循环长度。
</p>
<p>
	<span style="line-height:1.5;"><br />
</span>
</p>
<p>
	<span style="line-height:1.5;">数据规模：</span>
</p>
<p>
	对于30%的数据，k&lt;=4；
</p>
<p>
	对于全部的数据，k&lt;=100。<br />
	<div>
		<span style="line-height:1.5;"></span>
	</div>
</p>]]></input> 
<output><![CDATA[<p>
	每组输出包括一行，这一行只包含一个整数，表示循环长度。如果循环不存在，输出-1。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[32 2]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <test_input><![CDATA[78910912 4
]]></test_input>
<test_output><![CDATA[500
]]></test_output>
<test_input><![CDATA[5620736990256300764318310272826219441043313863371669821412552003434215914094675491613999450621484201 99
]]></test_input>
<test_output><![CDATA[5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[7193413765802634350416218285019420557763424682601360591210445057906482650997926303303073266013689023 90
]]></test_input>
<test_output><![CDATA[3125000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[125 3
]]></test_input>
<test_output><![CDATA[2
]]></test_output>
<test_input><![CDATA[2703485881763580303954324982653582970623573627633938495472255316727375360049953552593098516697780783 95
]]></test_input>
<test_output><![CDATA[1250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[7659978798503192720215080428071111033229273679525167853782727937186685901929284224474998117809488717 100
]]></test_input>
<test_output><![CDATA[500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[2820826094422589705284072407660794666219073208000509400188971347462012807391113061241705383522573263 50
]]></test_input>
<test_output><![CDATA[1250000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[4258161756319813789273201815945700206240682325082659165160258449299542088911212464353263203289007789 85
]]></test_input>
<test_output><![CDATA[500000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[9347147009766355127063373774379576550690862470473708730411978395107715169508952179550419799951258353 89
]]></test_input>
<test_output><![CDATA[1250000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]></test_output>
<test_input><![CDATA[1232135 4
]]></test_input>
<test_output><![CDATA[-1
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组-2005年NOIP全国联赛普及组]]></source>
		<solution language="Pascal"><![CDATA[type arr=array[0..200]of longint;
var i,j,k,m,n:longint;
    ans:arr;
    a,b,d,e:arr;
    s:string;
function compare(k:longint):boolean;
var i:longint;
begin
     if a[k]=e[k] then exit(true);
     exit(false);
end;
function c(a,b:arr):arr;
var i,j:longint;
begin
     fillchar(c,sizeof(c),0);
     for i:=1 to a[0] do
     for j:=1 to b[0] do if i+j-1<=k then
     begin
          inc(c[i+j-1],(a[i]*b[j])mod 10);
          inc(c[i+j],(a[i]*b[j])div 10 +c[i+j-1] div 10);
          c[i+j-1]:=c[i+j-1] mod 10;
     end;
     c[0]:=k;
     while (c[c[0]]=0)and(c[0]>0) do dec(c[0]);
end;
function mul(k:longint):arr;
var i,j:longint;
begin
     fillchar(mul,sizeof(mul),0);
     for i:=1 to ans[0] do
     begin
          inc(mul[i],ans[i]*k);
          inc(mul[i+1],mul[i] div 10);
          mul[i]:=mul[i] mod 10;
     end;
     inc(mul[0],ans[0]+4);
     while (mul[mul[0]]=0)and(mul[0]<>0) do dec(mul[0]);
end;
begin
     ans[0]:=1; ans[1]:=1;
     readln(s);
     i:=pos(' ',s);
     for j:=i+1 to length(s) do
     k:=k*10+ord(s[j])-48;
     delete(s,i,length(s)-i+1); j:=0;
     for i:=length(s) downto 1 do
     begin
          inc(j);
          a[j]:=ord(s[i])-48;
     end;
     a[0]:=k;
     d:=a;
     e:=a;
     b[0]:=1; b[1]:=1;
     i:=1;
     j:=0;
     while true do
     begin
          if j>10 then
          begin writeln(-1); halt; end;
          inc(j);
          b:=c(b,d);
          a:=c(e,b);
          if compare(i) then
          begin
               d:=b;
               fillchar(b,sizeof(b),0);
               b[0]:=1; b[1]:=1;
               inc(i);
               ans:=mul(j);
               if i>k then break;
               j:=0;
          end;
     end;
     for i:=ans[0] downto 1 do write(ans[i]);
end.]]></solution>
	</item>
</fps>
