<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[可乐]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[64]]></memory_limit>

<description><![CDATA[加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可
乐机器人，并且放在了加里敦星球的1号城市上。这个可乐机器人有三种行为：
停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现
在给出加里敦星球城市图，在第0秒时可乐机器人在1号城市，问经过了t秒，可
乐机器人的行为方案数是多少？&nbsp;]]></description>
<input><![CDATA[第一行输入两个正整数N, M，N表示城市个数，M表示道路个数。(1 ≤
N ≤ 30, 0 ≤ M ≤ 100)
接下来M行输入u, v，表示u, v之间有一条道路。(1 ≤ u, v ≤ n)保证两座城
市之间只有一条路相连。
最后输入时间t。&nbsp;]]></input> 
<output><![CDATA[输出可乐机器人的行为方案数，答案可能很大，请输出对2017取模后的结
果。&nbsp;]]></output>
<sample_input><![CDATA[3 2
1 2
2 3
2
]]></sample_input>
<sample_output><![CDATA[8
]]></sample_output>
  <test_input><![CDATA[30 100
21 4
15 29
22 28
2 4
7 26
21 6
3 4
1 28
26 17
26 24
12 14
8 16
2 13
5 12
18 26
29 30
30 13
20 21
2 21
16 9
8 29
6 10
24 6
29 11
22 25
4 26
30 11
11 1
15 7
5 24
8 13
6 9
26 14
17 3
12 15
20 3
7 4
27 10
29 18
12 1
11 18
12 23
9 5
9 14
25 26
27 3
17 25
26 29
27 2
2 16
3 14
23 28
19 4
21 28
30 28
13 1
28 10
10 23
8 7
24 9
22 26
30 16
1 21
21 24
11 9
19 1
6 19
20 11
19 23
22 11
25 11
28 11
20 29
24 10
14 4
18 2
26 16
6 11
22 9
3 8
11 24
18 22
27 16
25 16
6 18
25 19
13 5
12 8
20 16
22 7
7 21
2 26
2 29
7 23
30 10
16 10
20 22
10 13
28 29
27 4
1000000]]></test_input>
<test_output><![CDATA[1653
]]></test_output>
<test_input><![CDATA[30 100
18 21
1 28
7 8
4 11
19 14
1 25
28 26
30 3
9 18
15 30
15 2
23 5
13 20
12 30
22 29
20 23
18 26
30 13
29 18
27 21
12 16
8 4
10 17
21 17
16 27
18 30
1 24
18 6
13 21
19 16
19 29
11 18
11 1
28 29
21 1
6 29
15 17
24 22
13 11
13 6
4 22
11 9
13 15
13 23
22 23
21 2
10 24
25 29
14 15
5 25
19 11
3 12
24 16
14 6
13 10
10 2
29 14
24 20
6 7
30 7
6 5
14 5
16 10
21 4
21 24
7 14
1 13
12 13
14 1
27 23
24 25
6 17
6 11
23 18
17 14
17 22
19 30
22 21
24 28
27 24
2 8
6 15
30 24
29 23
1 23
28 16
28 9
17 8
5 18
8 26
8 1
15 4
16 9
3 13
15 24
16 23
1 9
7 29
24 8
5 22
1000]]></test_input>
<test_output><![CDATA[1797
]]></test_output>
<test_input><![CDATA[30 100
18 8
25 20
13 23
24 8
24 16
18 27
21 23
28 6
24 26
26 25
3 29
21 10
29 23
17 18
24 5
16 21
11 1
29 26
16 8
22 7
22 19
12 15
6 29
1 9
27 4
12 10
13 2
2 29
12 18
25 28
5 2
19 7
2 9
2 18
8 15
16 29
5 1
17 5
9 14
30 13
14 8
2 25
25 19
15 30
6 14
25 30
1 2
14 16
22 9
4 26
10 20
22 10
25 21
24 20
6 11
5 12
2 17
6 8
29 30
23 12
7 6
13 10
1 22
21 14
23 16
26 7
16 19
26 2
28 23
5 6
2 3
22 16
7 28
29 14
2 20
27 15
22 12
26 9
6 23
2 10
16 6
7 4
26 30
28 18
16 4
7 29
17 1
9 13
8 22
24 3
1 21
22 2
19 27
24 7
27 21
17 22
2 30
19 5
15 5
28 15
1000000]]></test_input>
<test_output><![CDATA[1740
]]></test_output>
<test_input><![CDATA[30 100
22 29
21 4
20 11
5 23
14 20
1 19
8 17
17 22
23 28
24 12
24 9
5 19
14 15
22 16
18 28
7 2
26 19
27 7
22 2
29 27
13 22
8 20
8 24
3 30
22 19
3 15
27 8
25 3
18 9
13 16
2 1
5 29
7 26
30 28
14 4
19 21
23 18
15 18
17 6
6 20
19 7
26 10
14 13
10 27
29 12
19 25
10 25
12 1
22 25
4 10
8 18
27 22
27 6
19 2
17 30
26 5
28 21
6 12
26 15
30 16
12 13
19 4
29 14
5 6
19 20
21 7
29 9
25 26
21 30
7 8
23 24
12 27
16 21
11 5
3 23
3 16
21 1
24 15
6 3
14 12
1 28
27 23
14 30
14 2
21 12
20 7
3 4
15 5
11 27
6 26
4 24
2 9
18 7
12 18
4 30
3 17
30 13
20 13
15 10
24 26
1000000]]></test_input>
<test_output><![CDATA[734
]]></test_output>
<test_input><![CDATA[30 100
16 1
11 7
10 5
10 16
19 17
26 12
23 17
11 9
16 15
7 9
26 28
30 20
29 12
26 5
27 11
5 8
9 6
4 18
5 1
25 27
17 4
12 4
3 10
8 12
10 6
23 27
10 19
29 6
18 8
12 21
25 17
4 21
17 29
17 3
24 13
21 5
8 24
15 20
1 23
19 15
19 20
3 9
17 21
16 20
23 14
19 2
16 12
14 7
8 22
22 14
3 5
27 3
27 7
17 7
18 11
15 5
16 26
25 22
16 17
5 4
18 13
15 24
11 22
7 2
28 9
6 24
11 24
1 19
30 10
6 14
28 22
9 22
19 18
13 3
11 23
29 19
14 21
7 13
30 28
11 6
11 8
30 1
26 30
1 14
17 14
8 20
6 23
6 22
28 15
3 26
30 15
29 10
12 9
10 8
30 14
22 1
19 8
14 26
18 17
2 3
1000000]]></test_input>
<test_output><![CDATA[20
]]></test_output>
<test_input><![CDATA[30 100
9 13
8 14
27 6
8 24
9 2
8 9
12 1
22 24
12 4
30 22
22 1
17 23
2 4
20 19
17 20
23 24
25 20
29 3
5 30
26 5
8 7
27 22
22 21
16 3
24 15
7 3
30 1
6 11
19 14
23 11
7 17
22 28
11 19
19 6
15 26
4 11
9 25
23 25
19 9
1 13
16 8
8 4
9 18
18 1
20 24
18 4
13 28
26 6
19 21
8 27
8 30
21 26
30 15
21 6
21 20
10 30
29 19
22 18
13 17
29 26
17 16
1 5
6 30
2 5
30 14
1 7
22 9
28 4
20 29
25 18
28 20
17 10
6 7
6 23
14 28
19 12
28 12
16 19
26 16
17 22
23 27
30 3
22 15
13 3
4 27
23 22
8 12
4 23
30 29
1 16
12 30
16 4
26 11
30 7
25 27
12 22
17 11
20 9
3 27
12 11
1000000]]></test_input>
<test_output><![CDATA[254
]]></test_output>
<test_input><![CDATA[30 100
5 4
25 2
20 18
12 7
1 8
13 15
5 14
2 10
2 30
19 16
27 3
2 18
2 12
27 9
8 4
11 4
8 5
5 19
23 16
17 23
15 30
29 19
13 30
21 7
21 1
22 18
3 15
27 4
26 23
12 25
27 22
29 26
27 25
6 11
3 22
25 17
21 24
28 26
15 10
24 6
15 12
29 11
26 19
11 14
11 1
9 29
17 6
9 19
28 10
18 17
26 20
30 5
26 6
8 16
16 15
4 3
25 24
4 12
21 4
28 19
19 8
27 15
2 22
18 21
28 18
28 13
2 28
16 27
23 1
2 17
17 5
20 7
30 4
24 28
14 4
5 11
2 5
20 12
29 14
29 22
12 6
4 23
17 16
29 16
19 15
13 2
18 9
10 25
17 27
11 7
7 16
28 4
10 26
30 27
24 2
9 26
18 25
1 15
22 20
20 28
1000]]></test_input>
<test_output><![CDATA[480
]]></test_output>
<test_input><![CDATA[30 100
15 16
23 16
10 9
28 3
13 24
28 8
28 14
27 24
30 19
8 3
29 30
11 6
27 19
30 8
1 6
23 15
13 3
23 10
4 24
4 23
29 22
10 16
22 3
1 21
24 11
26 20
29 17
20 21
22 12
6 27
14 2
23 9
17 19
10 1
4 12
16 26
6 8
16 29
10 3
10 30
19 29
21 10
3 25
14 20
2 28
28 18
8 13
25 18
13 20
7 26
27 14
16 28
16 25
27 26
24 17
4 3
25 9
14 26
6 12
6 14
16 22
23 28
11 13
17 10
8 5
2 1
9 28
26 24
7 15
11 2
23 7
4 20
12 19
8 14
8 16
20 7
21 13
7 30
23 1
17 26
2 26
23 3
19 7
9 22
27 13
3 29
4 16
22 7
17 13
12 23
6 4
21 29
21 5
1 9
12 1
23 30
13 25
6 13
25 19
12 11
1000000]]></test_input>
<test_output><![CDATA[896
]]></test_output>
<test_input><![CDATA[30 100
2 13
21 20
14 11
26 14
10 7
5 13
22 29
4 10
1 8
21 27
21 8
18 11
7 14
3 27
9 17
21 11
30 3
30 5
14 17
10 15
23 6
27 15
4 1
16 26
30 6
23 20
13 10
30 11
16 24
8 16
11 28
26 2
23 17
25 16
12 18
13 8
24 17
30 1
4 29
7 18
10 11
20 9
14 27
25 21
12 5
10 30
28 2
8 3
29 3
12 15
10 5
1 9
27 26
8 25
6 9
28 25
21 4
1 24
30 2
23 27
21 24
25 23
4 6
7 5
2 29
13 28
24 12
15 29
21 12
15 30
22 5
3 14
15 13
20 10
2 7
18 30
11 19
28 15
9 22
12 9
4 27
8 17
23 2
18 6
24 14
7 27
27 1
25 14
30 27
11 3
11 29
17 22
7 12
10 6
29 27
2 8
12 25
14 19
19 29
23 18
1000000]]></test_input>
<test_output><![CDATA[895
]]></test_output>
<test_input><![CDATA[30 100
1 24
6 26
1 15
4 20
14 5
24 17
22 18
1 25
17 2
1 4
4 25
22 30
1 8
29 28
25 23
19 25
16 24
21 17
1 16
28 14
20 22
1 23
28 17
24 28
13 27
15 4
19 15
3 9
12 27
21 8
8 3
16 8
18 14
14 8
27 6
3 27
28 30
13 21
10 3
20 28
9 14
6 21
10 28
5 23
5 12
25 21
12 13
26 25
12 22
22 14
18 19
5 22
9 10
26 20
29 4
16 5
1 20
27 28
24 14
10 5
26 5
26 12
4 5
30 8
30 26
8 22
13 11
18 20
7 10
2 26
7 17
9 16
21 26
20 11
16 7
22 19
26 29
4 17
16 27
26 23
19 30
25 6
11 2
27 14
20 27
29 10
22 11
20 7
17 3
17 20
15 12
20 3
15 7
28 12
22 9
13 29
12 1
12 24
27 2
10 2
1000000]]></test_input>
<test_output><![CDATA[946
]]></test_output>
<hint><![CDATA[<p>
	<br />
</p>
<p>
	样例解释
</p>
<p>
	&nbsp;1− &gt;爆炸
</p>
<p>
	&nbsp;1− &gt; 1− &gt;爆炸
</p>
<p>
	&nbsp;1− &gt; 2− &gt;爆炸
</p>
<p>
	&nbsp;1− &gt; 1− &gt; 1
</p>
<p>
	&nbsp;1− &gt; 1− &gt; 2&nbsp;
</p>
<p>
	1− &gt; 2− &gt; 1
</p>
<p>
	&nbsp;1− &gt; 2− &gt; 2
</p>
<p>
	&nbsp;1− &gt; 2− &gt; 3&nbsp;
</p>
<p>
	数据范围&nbsp;
</p>
<p>
	对于20%的数据，有1 &lt; t ≤ 1000&nbsp;
</p>
<p>
	对于100%的数据，有1 &lt; t ≤ 106。
</p>
<p>
	<br />
</p>
<p>
	<br />
</p>]]></hint>
<source><![CDATA[TJOI2017 NOIP TJOI2017day1 高级]]></source>
		<solution language="C++"><![CDATA[#include<cstdio>  
#include<iostream>  
#include<algorithm>  
#include<cstdlib>  
#include<cstring>
#include<string>
#include<climits>
#include<vector>
#include<cmath>
#include<map>
#define LL long long
 
using namespace std;
 
inline char nc(){
  static char buf[100000],*p1=buf,*p2=buf;
  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2) return EOF; }
  return *p1++;
}
 
inline void read(int &x){
  char c=nc();int b=1;
  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;
  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;
}
 
inline void read(LL &x){
  char c=nc();LL b=1;
  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;
  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;
}

inline int read(char *s)
{
    char c=nc();int len=0;
    for(;!((c>='A' && c<='Z')||(c>='a' && c<='z'));c=nc()) if (c==EOF) return 0;
    for(;((c>='A' && c<='Z')||(c>='a' && c<='z'));s[len++]=c,c=nc());
    s[len++]='\0';
    return len;
}

inline void read(char &x){
  for (x=nc();!(x=='?' || x=='+' || x=='-');x=nc());
}

int wt,ss[19];
inline void print(int x){
    if (x<0) x=-x,putchar('-'); 
    if (!x) putchar(48); else {
    for (wt=0;x;ss[++wt]=x%10,x/=10);
    for (;wt;putchar(ss[wt]+48),wt--);}
}
inline void print(LL x){
    if (x<0) x=-x,putchar('-');
    if (!x) putchar(48); else {for (wt=0;x;ss[++wt]=x%10,x/=10);for (;wt;putchar(ss[wt]+48),wt--);}
}

int n,m,T,f[40],g[40];
const int mo=2017;
struct data
{
    int f[40][40];
}a,b;

void add(data &x,data y)
{
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            x.f[i][j]=(x.f[i][j]+y.f[i][j])%mo;
}

void mul(data &x,data y)
{
    data z;
    memset(z.f,0,sizeof(z.f));
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            for (int k=1;k<=n;k++)
                z.f[i][j]=((x.f[i][k]*y.f[k][j])%mo+z.f[i][j])%mo;
    x=z;
}

data Power(data x,int y)
{
    data res;
    memset(res.f,0,sizeof(res.f));
    for (int i=1;i<=n;i++)
        res.f[i][i]=1;
    for (;y;y>>=1)
    {
        if (y&1) mul(res,x);
        mul(x,x);
    }
    return res;
}

data Sum(data x,int y)
{
    data res;
    memset(res.f,0,sizeof(res.f));
    if (y==0) return res;
    if (y==1) return x;
    for (int i=1;i<=n;i++)
        res.f[i][i]=1;
    add(res,Power(x,y>>1));mul(res,Sum(x,y>>1));
    if (y&1) add(res,Power(x,y));
    return res;
}

int main()
{
    read(n);read(m);
    int x,y;
    memset(a.f,0,sizeof(a.f));
    for (int i=1;i<=m;i++)
        read(x),read(y),a.f[x][y]=1,a.f[y][x]=1;
    for (int i=1;i<=n;i++)
        a.f[i][i]=1;
    read(T);
    b=a;
    a=Power(a,T);
    memset(g,0,sizeof(g));
    memset(f,0,sizeof(f));
    g[1]=1;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            f[i]=((g[j]*a.f[i][j])%mo+f[i])%mo;
    int ans=0;
    for (int i=1;i<=n;i++)
        ans=(ans+f[i])%mo;
    b=Sum(b,T-1);
    for(int i=1;i<=n;i++)
        b.f[i][i]=(b.f[i][i]+1)%mo; 
    memset(g,0,sizeof(g));
    memset(f,0,sizeof(f));
    g[1]=1;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            f[i]=((g[j]*b.f[i][j])%mo+f[i])%mo;
    for (int i=1;i<=n;i++)
        ans=(ans+f[i])%mo;
    print(ans),puts("");
    return 0;
}]]></solution>
	</item>
</fps>
