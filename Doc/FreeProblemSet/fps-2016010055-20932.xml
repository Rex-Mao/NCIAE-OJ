<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[字串变换]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[已知有两个字串A$，B$及一组字串变换的规则（至多6个规则）：<br />
<p>
	<span style="line-height:1.5;">A1$ -&gt; B1$</span> 
</p>
<p>
	<span style="line-height:1.5;">A2$ -&gt; B2$</span> 
</p>
规则的含义为：在 A$中的子串A1$可以变换为B1$、A2$可以变换为B2$...<br />
<p>
	<br />
</p>
<p>
	例如：A$＝'abcd'　B$＝'xyz'
</p>
<p>
	&nbsp; 变换规则为：
</p>
<p>
	&nbsp; 'abc'-&gt;'xu'　'ud'-&gt;'y'　'y'-&gt;'yz'
</p>
<p>
	&nbsp; 则此时，A$可以经过一系列的变换变为B$，其变换的过程为：
</p>
&nbsp; &nbsp; &nbsp;'abcd'-&gt;'xud'-&gt;'xy'-&gt;'xyz'<br />
<p>
	&nbsp; 共进行了三次变换，使得A$变换为B$。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入的第一行输入两个字符串A$和B$。
</p>
<p>
	接下来若干行输入变换规则：
</p>
<p>
	A$ B$<br />
A1$ B1$ \<br />
A2$ B2$ &nbsp;|-&gt; 变换规则<br />
... ... &nbsp; &nbsp; &nbsp;/
</p>
<p>
	所有字符串长度的上限为 20。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，若在10步（包含10步）以内能将A$变换为B$，则输出最少的变换步数，否则输出"NO ANSWER!"。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[abcd wyz
abc xu
ud y
y yz]]></sample_input>
<sample_output><![CDATA[3]]></sample_output>
  <test_input><![CDATA[abaaaba abcdaba
a b
b d
d e
e f
f g
g c
]]></test_input>
<test_output><![CDATA[8
]]></test_output>
<test_input><![CDATA[program procedure
g ce
ra dur
am ee
ee am
]]></test_input>
<test_output><![CDATA[NO ANSWER!
]]></test_output>
<test_input><![CDATA[((T+F)+(F+F))+(F+T) F
T+T F
T+F T
F+T T
F+F F
(T) T
(F) F
]]></test_input>
<test_output><![CDATA[9
]]></test_output>
<test_input><![CDATA[abcdefgh 12345678
abcd efgh
efgh 1234
efgh 5678
]]></test_input>
<test_output><![CDATA[3
]]></test_output>
<test_input><![CDATA[a aaaaa
a a112233445566778899
778899 a
112233 a
445 a
566 a
55 a
]]></test_input>
<test_output><![CDATA[5
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2002年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

struct node
{
    char s[30];
    int dep;
} list1[5010],list2[5010];

char a[7][30],b[7][30];
int n;
bool check(char *s1,char *s2)
{
    if (strlen(s1)!=strlen(s2)) return false;
    for (int i=0;i<strlen(s1);i++)
        if (s1[i]!=s2[i]) return false;
    return true;
}
bool pan1(char *s,int i,int x)
{
    for (int j=i;j<i+strlen(a[x]);j++)
        if (s[j]!=a[x][j-i]) return false;
    return true;
}
bool pan2(char *s,int i,int x)
{
    for (int j=i;j<i+strlen(b[x]);j++)
        if (s[j]!=b[x][j-i]) return false;
    return true;
}
void bfs()
{
    int head1,tail1,head2,tail2,i,j,k,l;
    head1=tail1=head2=tail2=1;

    while (head1<=tail1 && head2<=tail2)
    {
        if (list1[head1].dep+list2[head2].dep>10)
        {
            printf("NO ANSWER!\n");
            return ;
        }
        for ( i=0;i<strlen(list1[head1].s);i++)
            for ( j=1;j<=n;j++)
                if (pan1(list1[head1].s,i,j))
                {
                  tail1++;
                  for (k=0;k<i;k++) list1[tail1].s[k]=list1[head1].s[k];

                  for (l=0;l<strlen(b[j]);l++,k++) list1[tail1].s[k]=b[j][l];

                  for (l=i+strlen(a[j]);l<=strlen(list1[head1].s);l++,k++)
                     list1[tail1].s[k]=list1[head1].s[l];

                  list1[tail1].s[k]='\0';
                  list1[tail1].dep=list1[head1].dep+1;

                  for (k=1;k<=tail2;k++)
                    if (check(list1[tail1].s,list2[k].s))
                    {
                       printf("%d\n",list1[tail1].dep+list2[k].dep);
                       return ;
                     }
                }

        for ( i=0;i<strlen(list2[head2].s);i++)
            for ( j=1;j<=n;j++)
                if (pan2(list2[head2].s,i,j))
                {
                  tail2++;
                  for (k=0;k<i;k++) list2[tail2].s[k]=list2[head2].s[k];
                  for ( l=0;l<strlen(a[j]);l++,k++) list2[tail2].s[k]=a[j][l];
                  for (l=i+strlen(b[j]);l<=strlen(list2[head2].s);l++,k++)
                    list2[tail2].s[k]=list2[head2].s[l];
                  list2[tail2].s[k]='\0';
                  list2[tail2].dep=list2[head2].dep+1;
                  for (k=1;k<=tail1;k++)
                    if (check(list1[k].s,list2[tail2].s))
                    {
                       printf("%d\n",list1[k].dep+list2[tail2].dep);
                       return ;
                    }
                }
        head1++; head2++;
    }
    printf("NO ANSWER!\n");
}

int main()
{

    scanf("%s%s",list1[1].s,list2[1].s);
    n=1;
    while (scanf("%s%s",a[n],b[n])!=EOF) n++;
    n--;
    list1[1].dep=list2[1].dep=0;
    bfs();
    return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[const
 maxn=2300;
type
 node=record  
  str:string;
  dep:longint;
 end;
 ctype=array[1..maxn]of ^node;
 bin=0..1;
var
 maxk:byte;c:array [0..1]of ctype;
 x0:array[0..6,0..1]of string;
 open,guan:array [0..1] of longint;
procedure init;
var
 temp:string;
 i,j:longint;
begin
 for i:=0 to 1 do
  for j:=1 to maxn do
   new(c[i,j]);
 i:=0;
 while not eof and (i<=6) do
 begin
  readln(temp);
  x0[i,0]:=copy(temp,1,pos(' ',temp)-1);
  x0[i,1]:=copy(temp,pos(' ',temp)+1,length(temp));
  inc(i);
 end;
 maxk:=i-1;
end;
procedure calc;
var
 st:bin;
 d:string;
procedure bool(st:bin);
var
 i:longint;
begin
 if x0[0,1-st]=c[st,guan[st]]^.str then
 begin
  writeln(c[st,guan[st]]^.dep);
  halt;
 end;
 for i:=1 to guan[1-st] do
  if c[st,guan[st]]^.str=c[1-st,i]^.str then
  begin
   writeln(c[st,guan[st]]^.dep+c[1-st,i]^.dep);
   halt;
  end;
end;
procedure checkup(st:bin);
var
 i:longint;
begin
 for i:=1 to guan[st]-1 do
  if c[st,i]^.str=c[st,guan[st]]^.str then
  begin
   dec(guan[st]);
   exit;
  end;
 bool(st);
end;
procedure expand(st:bin);
var
 i,j,k,lx,ld:longint;
begin
 inc(open[st]);
 d:=c[st,open[st]]^.str;
 k:=c[st,open[st]]^.dep;
 ld:=length(d);
 for i:=1 to maxk do
 begin
  lx:=length(x0[i,st]);
  for j:=1 to ld do
  begin
   if (copy(d,j,lx)=x0[i,st]) and (length(copy(d,1,j-1)+x0[i,1-st]+copy(d,j+lx,ld))<=115) then
   begin
    if guan[st]>=maxn then exit;
    inc(guan[st]);
    c[st,guan[st]]^.str:=copy(d,1,j-1)+x0[i,1-st]+copy(d,j+lx,ld);
    c[st,guan[st]]^.dep:=k+1;
    checkup(st);
   end;
  end;
 end;
end;
begin
 for st:=0 to 1 do
 begin
  open[st]:=0;
  guan[st]:=1;
  c[st,guan[st]]^.str:=x0[0,st];
  c[st,guan[st]]^.dep:=0;
  bool(st);
 end;
 repeat
  if (open[0]<=open[1]) and not ((open[0]>=guan[0]) or (guan[0]>=maxn) or (c[0,guan[0]]^.dep>10)) then expand(0);
  if (open[1]<=open[0]) and not ((open[1]>=guan[1]) or (guan[1]>=maxn) or (c[1,guan[1]]^.dep>10)) then expand(1);
  if not ((open[0]>=guan[0]) or (guan[0]>=maxn) or (c[0,guan[0]]^.dep>10)) then expand(0);
  if not ((open[1]>=guan[1]) or (guan[1]>=maxn) or (c[1,guan[1]]^.dep>10)) then expand(1);
 until (open[0]>=guan[0]) or (c[0,guan[0]]^.dep>10) or (guan[0]>=maxn) and (guan[1]>=maxn) or (open[1]>=guan[1]) or (c[1,guan[1]]^.dep>10);
end;
begin
 init;
 calc;
 writeln('NO ANSWER!');
end. ]]></solution>
	</item>
</fps>
