<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[潜伏者]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	R国和S国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。
</p>
<p>
	历经艰险后，潜伏于S国的R国间谍小C终于摸清了S国军用密码的编码规则：
</p>
<p>
	<span style="line-height:1.5;">1. S国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所的内容均由大写字母‘A’—‘Z’构成（无空格等其他字母）。</span> 
</p>
<p>
	2. S国对于每个字母规定了对应的“密字”。加密的过程就是将原信息中的所有字母替换为其对应的“密字”。
</p>
<p>
	3. 每个字母只对应一个唯一的“密字”，不同的字母对应不同的“密字”。“密字”可以和原字母相同。
</p>
<p>
	例如，若规定‘A’的密字为‘A’，‘B’的密字为‘C’（其他字母及密字略），则原信息“ABA”被加密为“ACA”。
</p>
<p>
	现在，小C通过内线掌握了S国网络上发送的一条加密信息及其对应的原信息。小C希望能通过这条信息，破译S国的军用密码。小C的破译过程是这样的：扫描原信息，对于原信息中的字母x（代表任一大写字母），找到其在加密信息中的对应大写字母y，并认为在密码里y是x的密字。如此进行下去直到停止于如下的某个状态：
</p>
<p>
	1. 所有信息扫描完毕，‘A’—‘Z’所有26个字母在原信息中均出现过并获得了相应的“密字”。
</p>
<p>
	2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。
</p>
<p>
	3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反S过密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。
</p>
<p>
	在小C忙得头昏脑胀之际，R国司令部又发来电报，要求他翻译另外一条从S国刚刚截取到的加密信息。现在请你帮助小C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据共3行，每行为一个长度在1到100之间的字符串。
</p>
<p>
	第1行为小C掌握的一条加密信息。
</p>
<p>
	第2行为第1行的加密信息所对应的原信息。
</p>
<p>
	第3行为R国司令部要求小C翻译的加密信息。
</p>
<p>
	输入数据保证所有字符串仅由大写字母‘A’—‘Z’构成，且第1行长度与第2行相等。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	每组输出共1行。
</p>
<p>
	若破译密码停止时出现2，3两种情况，请你输出“Failed”（不含引号，注意首字母大写，其它小写）。
</p>
<p>
	否则请输出利用密码翻译电报中加密信息后得到的原信息。
</p>
<p>
	<br />
</p>
<p>
	下面是对样例数据的解释：
</p>
<p>
	样例一：
</p>
<p>
	原信息中的字母‘A’和‘B’对应相同的密字，输出“Failed”。
</p>
<p>
	样例二：
</p>
<p>
	字母‘Z’在原信息中没有出现，输出“Failed”。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[AA
AB
EOWIE

QWERTYUIOPLKJHGFDSAZXCVBN
ABCDEFGHIJKLMNOPQRSTUVWXY
DSLIEWO

MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO]]></sample_input>
<sample_output><![CDATA[Failed

Failed

NOIP]]></sample_output>
  <test_input><![CDATA[MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
X
]]></test_input>
<test_output><![CDATA[X
]]></test_output>
<test_input><![CDATA[SZIFNCVGWBKJQUYLHODEMAPTXRPCKVPLBMXVPDIF
CEOXQBDPVTLHMFRGWSYUNIAKJZABLDAGTNJDAYOX
LFXQYHHEVMLKJJPCYIPGVOXALOYWLD
]]></test_input>
<test_output><![CDATA[GXJMRWWUDNGLHHABROAPDSJIGSRVGY
]]></test_output>
<test_input><![CDATA[TVREHAIBYFXWDSMULQPNOGJZCKEBNFRERHLENNFVJJJHYGGPVVGGOIWFCIBUVKRQLXKISZCTJFJYEZFB
PKAHTOVYMXCFQUGSNRIEJDZLWBHYEXAHATNHEEXKZZZTMDDIKKDDJVFXWVYSKBARNCBVULWPZXZMHLXY
YAYZQYVCJHIZNCKUVFBCLMAFDTUTNEWEYBBXUEAKKYKZBCJGERKJOXVBQAHOMZHHLHOOOBNYHYFGWXZHOROELTMYDW
]]></test_input>
<test_output><![CDATA[MOMLRMKWZTVLEWBSKXYWNGOXQPSPEHFHMYYCSHOBBMBLYWZDHABZJCKYROTJGLTTNTJJJYEMTMXDFCLTJAJHNPGMQF
]]></test_output>
<test_input><![CDATA[YGDPSJLOQHCUFEKZAWRMXNTIBVGJIF
TZQHUCGNERMPWFYJKBLSODVAIXZCAW
XRBAIUIFXH
]]></test_input>
<test_output><![CDATA[OLIKAPAWOR
]]></test_output>
<test_input><![CDATA[AAQWERTYUIOPLKJHGFDSAZXCVBNM
ABQWERTYUIOPLKJHGFDSAZXCVBNM
HELLO
]]></test_input>
<test_output><![CDATA[Failed
]]></test_output>
<test_input><![CDATA[QWERTYUIOPLKJHGFDSAZXCVBNM
ABCDEFGHIJKLMNOPQRSTUVWXYZ
IQHPOQKGHU
]]></test_input>
<test_output><![CDATA[HANJIALONG
]]></test_output>
<test_input><![CDATA[QWERTYUIOPLKJHGFDSAZXCVBNM
QWERTYUIOPLKJHGFDSAZXCVBNN
HIJACK
]]></test_input>
<test_output><![CDATA[Failed
]]></test_output>
<test_input><![CDATA[IHFQVULZAKORXESYBCMGPDTWJNUQIDDWDKNXAYOKPQUWUDLAOPBRCLCEQQWO
VJCFWTEUMIHRAPOZXSGKBYQDNLTFVYYDYILAMZHIBFTDTYEMHBXRSESPFFDH
NZFRRZORRDGVDMUADDYTNCVBOJLLDMCSLIHEIIZAEKMKKKVFYBCJFOPUWDXFPLVFKCLTLW
]]></test_input>
<test_output><![CDATA[LUCRRUHRRYKWYGTMYYZQLSWXHNEEYGSOEVJPVVUMPIGIIIWCZXSNCHBTDYACBEWCISEQED
]]></test_output>
<test_input><![CDATA[XOCKPGHZQWTRLEMBIYJNFVUSADIPLOEQSNIGYQLBFDYNKKOCCIFEWYAAVXKBPHRXDWLKLWQFLIYFCMZGJFANGLUDCTWDUAJNFEUA
WDGASYNVPHLQRCMXJFTOIKEZUBJSRDCPZOJYFPRXIBFOAADGGJICHFUUKWAXSNQWBHRARHPIRJFIGMVYTIUOYREBGLHBEUTOICEU
KSDPBTWJMVQKSNABRIIOAVUZXQXONXNYGBOKMQKDGEKSMBQGYXLCLEYBDMMOSVXCNYDVEGWBLCHYYSFDVZYVBLZQUWDJTOJFSLTC
]]></test_input>
<test_output><![CDATA[AZBSXLHTMKPAZOUXQJJDUKEVWPWDOWOFYXDAMPABYCAZMXPYFWRGRCFXBMMDZKWGOFBKCYHXRGNFFZIBKVFKXRVPEHBTLDTIZRLG
]]></test_output>
<test_input><![CDATA[A
A
A
]]></test_input>
<test_output><![CDATA[Failed
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组-2009年NOIP全国联赛提高组]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	char a[100],b[100],c[100],ch;
	int i=0,j=0,t=0,r=0,p=1;
	scanf("%s%s%s",a,b,c);
	for(t=0;a[t]!='\0';t++)
	{
		for(r=0;a[r]!='\0';r++)
		{
			if(a[t]==a[r]&&b[t]!=b[r])
				p=0;
		}
		for(ch='A';ch<='Z';ch++)
		{
			for(i=0;b[i]!='\0';i++)
				if(b[i]==ch)
					break;
			if(b[i]=='\0')
			{
				p=0;
				break;
			}
		}

		if(p==0)
			break;
	}
	if(p!=0)
	{
		for(t=0;c[t]!='\0';t++)
		{
			for(r=0;a[r]!='\0';r++)
			{
				if(a[r]==c[t])
				{
					c[t]=b[r];
					break;
				}
			}
		}
		for(t=0;c[t]!='\0';t++)
			printf("%c",c[t]);
	}
	else
		printf("Failed");
	printf("\n");
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<cstdio>
#include<stdlib.h>
#include<string.h>
#define SIZE 30
#define BUF_SIZE 110
int dict1[SIZE];
int dict2[SIZE];
char buf1[BUF_SIZE];
char buf2[BUF_SIZE];
char code[BUF_SIZE];
int decode(){
	int len=strlen(buf1);
	int i,c1,c2;
	for(i=0;i<len;i++){
		c1=buf1[i]-'A'+1;
		c2=buf2[i]-'A'+1;
		if(dict1[c1]==c2 && dict2[c2]==c1)continue;
		else if(!dict1[c1] && !dict2[c2])
		dict1[c1]=c2,dict2[c2]=c1;
		else return 0;
	}
	for(i=1;i<=26;i++)
	if(!dict1[i])return 0;
	return 1;
}
int main(){
	scanf("%s%s%s",buf1,buf2,code);
	if(decode()){
		int i;
		for(i=0;code[i]!='\0';i++)
		putchar(dict1[code[i]-'A'+1]+'A'-1);
		putchar('\n');
	}
	else puts("Failed");
	return 0;  
}]]></solution>
			<solution language="Pascal"><![CDATA[var
  a:array['A'..'Z'] of char;
  b:array['A'..'Z'] of boolean;
  j,k,len:longint;
  s1,s2,s:string;
  i:char;
  suc:boolean;
begin

  begin
    readln(s1);
    readln(s2);
    readln(s);
    suc:=true;
    for i:='A' to 'Z' do
    begin
      b[i]:=false;
    end;
    len:=length(s1);
    for j:=1 to len do
    begin
      if b[s1[j]] then
        if a[s1[j]]=s2[j] then continue
        else
        begin
          suc:=false;
          writeln('Failed');
          break;
        end
      else
        for k:=1 to j-1 do if a[s1[k]]=s2[j] then
        begin
          suc:=false;
          writeln('Failed');
          break;
        end;
      a[s1[j]]:=s2[j];
      b[s1[j]]:=true;
      if not(suc) then break;
    end;
    if suc=false then exit;
    for i:='A' to'Z' do if not(b[i]) then
    begin
      writeln('Failed');
      exit;
    end;
    for j:=1 to length(s) do write(a[s[j]]);
    writeln;
  end;
end.
]]></solution>
			<solution language="Java"><![CDATA[import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
//多项式输出 HaiYi 14 199 
//Y Problem  B 分数线划定 HaiYi 17 109 
//N Problem  C 潜伏者 HaiYi 5 74 
//N Problem  D 数字统计 HaiYi 18 178 
//Y Problem  E 求质数 HaiYi 35 189 
// Problem  F 立体图 

public class Main {
	public static void main(String args[]) throws Exception {
		// 输入范围
		Scanner scanner = new Scanner(System.in);
		String coded = scanner.nextLine();
		String original = scanner.nextLine();
		String problem = scanner.nextLine();

		List<String> codeList = new ArrayList<String>();
		List<String> originalList = new ArrayList<String>();
		if (original.length() != coded.length()) {
			System.out.println("Failed");
			return;
		}
		for (int i = 0; i < coded.length(); i++) {
			codeList.add(coded.substring(i, i + 1));
			originalList.add(original.substring(i, i + 1));
		}

		// match2
		if (original.indexOf("A") < 0 || original.indexOf("B") < 0
				|| original.indexOf("C") < 0 || original.indexOf("D") < 0
				|| original.indexOf("E") < 0 || original.indexOf("F") < 0
				|| original.indexOf("G") < 0 || original.indexOf("H") < 0
				|| original.indexOf("I") < 0 || original.indexOf("J") < 0
				|| original.indexOf("K") < 0 || original.indexOf("L") < 0
				|| original.indexOf("M") < 0 || original.indexOf("N") < 0
				|| original.indexOf("O") < 0 || original.indexOf("P") < 0
				|| original.indexOf("Q") < 0 || original.indexOf("R") < 0
				|| original.indexOf("S") < 0 || original.indexOf("T") < 0
				|| original.indexOf("U") < 0 || original.indexOf("V") < 0
				|| original.indexOf("W") < 0 || original.indexOf("X") < 0
				|| original.indexOf("Y") < 0 || original.indexOf("Z") < 0) {
			System.out.println("Failed");
			return;
		}

		boolean flag = true;
		for (int i = 0; i < codeList.size(); i++) {
			String code = codeList.get(i);
			String ori = originalList.get(i);
			for (int j = 1; j < codeList.size(); j++) {
				if (codeList.get(j).equals(code)
						&& !originalList.get(j).equals(ori)) {
					flag = false;
					break;
				}
			}
		}
		if (!flag) {
			System.out.println("Failed");
			return;
		}

		String trans = "";
		for (int i = 0; i < problem.length(); i++) {
			String str = problem.substring(i, i + 1);
			for (int j = 0; j < codeList.size(); j++) {
				if (str.equals(codeList.get(j))) {
					trans += originalList.get(j);
					break;
				}
			}
		}
		System.out.println(trans);

	}

	public static int count(String str) {
		int count = 0;
		for (int i = 0; i < str.length(); i++) {
			if (str.substring(i, i + 1).equals("2")) {
				count++;
			}
		}
		return count;
	}
}
]]></solution>
	</item>
</fps>
