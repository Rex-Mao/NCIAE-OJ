<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[[ZJOI2009]多米诺骨牌]]></title>
<time_limit unit="s"><![CDATA[2]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	有一个n × m 的矩形表格，其中有一些位置有障碍。现在要在这个表格内 放一些1 × 2 或者2 × 1 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部 分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个 骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放 置方法，注意你并不需要放满所有没有障碍的格子。
</p>
<h2>
	输入输出格式
</h2>
<strong>输入格式：</strong><br />
<p>
	<br />
</p>
<p>
	第一行两个整数n;m。接下来n 行，每行m 个字符，表示这个矩形表格。 其中字符“x” 表示这个位置有障碍，字符“.” 表示没有障碍。
</p>
<p>
	<br />
</p>
<strong>输出格式：</strong><br />
<p>
	<br />
</p>
<p>
	一行一个整数，表示不同的放置方法数mod 19901013 的值。
</p>
<p>
	<br />
</p>
<h2>
	输入输出样例
</h2>
<div class="am-g">
	<div class="am-u-md-6 copy-region">
		<strong>输入样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>3 3
...
...
...</pre>
	</div>
	<div class="am-u-md-6 copy-region">
		<strong>输出样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>2</pre>
	</div>
</div>
<h2>
	说明
</h2>
<p>
	两种放置方法分别为
</p>
<p>
	112 411
</p>
<p>
	4.2 4.2
</p>
<p>
	433 332
</p>
<p>
	注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。
</p>
<p>
	数据范围
</p>
<p>
	对于40% 的数据，满足1 ≤ n;m ≤ 8。
</p>
<p>
	对于90% 的数据，满足1 ≤ n;m ≤ 14。
</p>
<p>
	对于100% 的数据，满足1 ≤ n;m ≤ 15。
</p>
<div class="lg-article-sub am-g" id="sub">
</div>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[14 12
.........x.x
........xx.x
..x.......x.
.x.xx.......
..x....x...x
..x....x...x
.......xx...
..x.........
.........x.x
x...x.......
..........xx
..x.....x..x
..x.x....x..
..x.x...xxx.
]]></test_input>
<test_output><![CDATA[12025413
]]></test_output>
<test_input><![CDATA[10 14
x...x.........
.....x........
..x........x.x
.......x..x.x.
...x....x..x..
....x..x..x..x
...x....xx.x..
......x.....x.
......x...xx..
.........x...x
]]></test_input>
<test_output><![CDATA[11142555
]]></test_output>
<test_input><![CDATA[12 12
..x.........
....x..x....
....xx.....x
....x.....x.
............
x...........
...........x
............
....x...x...
............
..x...xx....
..x.........
]]></test_input>
<test_output><![CDATA[14642380
]]></test_output>
<test_input><![CDATA[3 5
.x...
..x..
.x.x.
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<test_input><![CDATA[6 5
.x...
.....
.....
.....
.....
.....
]]></test_input>
<test_output><![CDATA[48432
]]></test_output>
<test_input><![CDATA[15 15
...x.....x...x.
............x..
.......x..x....
....x...x......
.......x......x
x........x.....
.....x...x....x
...............
.x......x....xx
..x........x...
x..........x.x.
......x........
............x..
...............
.x..xx.........
]]></test_input>
<test_output><![CDATA[6824395
]]></test_output>
<test_input><![CDATA[6 7
.xx.x.x
...x...
.xx..x.
xxxx.x.
x.xxxxx
x...xxx
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<test_input><![CDATA[8 8
xxx.....
x....xxx
x..xx.x.
x.x.....
........
xx....x.
.....xx.
..x.....
]]></test_input>
<test_output><![CDATA[243329
]]></test_output>
<test_input><![CDATA[13 14
x..x..........
.x..xxx..x....
.x...x.x.x....
....xx........
.x.....xxx.x..
.......x......
xx.xxx........
x..xxxxx...x.x
............x.
...x.......x.x
xxx..x.x......
.x.x......x.x.
.xx.xx.......x
]]></test_input>
<test_output><![CDATA[104207
]]></test_output>
<test_input><![CDATA[14 14
..x.....x.....
...........x..
...x.........x
.............x
..............
....x.........
....x.......xx
x...x..x.....x
..............
x.............
...xx....x....
xx...........x
xx............
xx.x..........
]]></test_input>
<test_output><![CDATA[9922682
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[ZJOI2009 省选 高级]]></source>
		<solution language="C++"><![CDATA[#include <cstdio>
#include <cstdlib>
#include <memory.h>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <cmath>
using namespace std;
#define PI 3.14159265358979323846264338327950288
#define MOD 19901013
int N, M;
int mat[25][25];
int ans[25][25][25][25];
int tmp[25][25][1 << 15];
int lg[(1 << 15) + 5];
#define lowbit(x) ((x) & -(x))
inline int genList(int x, int *p) {
   int ret = 0;
   while (x) {
      p[ret ++] = lg[lowbit(x)] + 1;
      x ^= lowbit(x);
   }
   return ret;
}
int main() {
   int i, j, k, l, r, u;
   //freopen("domino.in", "r", stdin);
   //freopen("domino.out", "w", stdout);
   scanf("%d%d", &N, &M);
   for (i = 0; i <= 15; i ++)
      lg[1 << i] = i;
   for (i = 0; i < N; i ++) {
      char tmp1[25];
      scanf("%s", tmp1);
      for (j = 0; j < M; j ++)
	 mat[i][j] = (tmp1[j] == '.' ? 1 : 0);
   }
   for (l = 0; l < M; l ++)
      for (r = l + 1; r <= M; r ++)
	 for (u = 0; u < N; u ++) {
	    int width = r - l;
	    int mask = (1 << width);
	    for (i = 0; i < mask; i ++)
	       tmp[u + 1][l][i] = 1;
	    for (i = u; i >= 0; i --) {
	       for (j = r - 1; j >= l; j --) {
		  int *prev = (j == r - 1 ? tmp[i + 1][l] : tmp[i][j + 1]);
		  int *cnt = &tmp[i][j][0];
		  if (!mat[i][j])
		     for (k = 0; k < mask; k ++, cnt ++)
			*cnt = prev[(k << 1) & (mask - 1)];
		  else
		     if (mat[i - 1][j] && mat[i][j - 1] && j > l) {
			for (k = 0; k < (mask >> 1); k ++, cnt ++) {
			   *cnt = prev[(k << 1) & (mask - 1)] + prev[(k << 1) + 1];
			   if (!(k & 1)) {
			      *cnt += prev[((k << 1) + 3) & (mask - 1)];
			      *cnt %= MOD;
			   }
			}
			for (; k < mask; k ++, cnt ++) {
			   *cnt = prev[(k << 1) & (mask - 1)];
			   if (!(k & 1)) {
			      *cnt += prev[((k << 1) + 3) & (mask - 1)];
			      *cnt %= MOD;
			   }
			}
		     }
		     else
			if (mat[i - 1][j]) {
			   for (k = 0; k < (mask >> 1); k ++, cnt ++)
			      *cnt = (prev[(k << 1) & (mask - 1)] + prev[(k << 1) + 1]) % MOD;
			   for (; k < mask; k ++, cnt ++)
			      *cnt = prev[(k << 1) & (mask - 1)];
			}
			else
			   if (mat[i][j - 1] && j > l)
			      for (k = 0; k < mask; k ++, cnt ++) {
				 *cnt = prev[(k << 1) & (mask - 1)];
				 if (!(k & 1)) {
				    *cnt += prev[((k << 1) + 3) & (mask - 1)];
				    *cnt %= MOD;
				 }
			      }
			   else
			      for (k = 0; k < mask; k ++, cnt ++)
				 *cnt = prev[(k << 1) & (mask - 1)];
	       }
	       ans[l][r][i][u + 1] = tmp[i][l][mask - 1];
	    }
	 }
   int list1[25], len1;
   long long ret = 0;
   for (i = 0; i < (1 << M - 1); i ++) {
      list1[0] = 0;
      len1 = genList(i, list1 + 1) + 1;
      list1[len1] = M;
      long long tmp2[25];
      tmp2[N] = (len1 % 2 ? -1 : 1);
      for (j = N - 1; j >= 0; j --) {
	 tmp2[j] = 0;
	 for (k = j + 1; k <= N; k ++) {
	    long long tmp3 = 1;
	    for (l = 0; l < len1; l ++) {
	       tmp3 *= ans[list1[l]][list1[l + 1]][j][k];
	       tmp3 %= MOD;
	    }
	    tmp2[j] -= tmp3 * tmp2[k];
	 }
	 tmp2[j] %= MOD;
      }
      ret += tmp2[0];
   }
   ret %= MOD;
   ret += MOD;
   ret %= MOD;
   printf("%d\n", (int)ret);
   return 0;
}
]]></solution>
	</item>
</fps>
