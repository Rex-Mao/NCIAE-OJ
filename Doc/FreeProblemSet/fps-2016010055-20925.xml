<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[统计单词个数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	给出一个长度不超过200的由小写英文字母组成的字母串（约定：该字串以每行20个字母的方式输入，且保证每行一定为20个）。要求将此字母串分成k份（1&lt;k&lt;=40），且每份中包含的单词个数加起来总数最大（每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可包含this和is，选用this之后就不能包含th）。
</p>
<p>
	单词在给出的一个不超过6个单词的字典中。
</p>
<p>
	<span style="line-height:1.5;">要求输出最大的个数。</span> 
</p>
<p>
	<span style="line-height:1.5;"><br />
</span> 
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，其格式如下：
</p>
<p>
	每组的第一行输入两个正整数p和k，p表示字串的行数，k表示分为k个部分。
</p>
<p>
	接下来的p行，每行均有20个字符。
</p>
再接下来一行输入一个正整数s（<span>1&lt;=s&lt;=6）</span>，表示字典中单词个数。<br />
<p>
	接下来的s行，每行输入一个单词。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出一个整数，分别对应每组测试数据的相应结果。
</p>
<p>
	下面是对样例数据的说明：
</p>
<p>
	样例数据中对字母串分割的方式是：this/isabookyoua/reaoh
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[1 3
thisisabookyouareaoh
4
is
a
ok
sab]]></sample_input>
<sample_output><![CDATA[7]]></sample_output>
  <test_input><![CDATA[10 4
sdfsdsassdasdddsasdd
sdasdsasdsadasdasdsa
assasaasadassadsaadd
ssasdasdasdssddsassa
asdasdasdasdasddsads
dsadasdasdasadssdssa
asssdasdsasdassdssaa
dsaddsasdasdsadsaasa
adsadsasddsadsadsssa
adsdsaasddsaadsdsasa
6
aa
sa
ds
da
sa
sd
]]></test_input>
<test_output><![CDATA[125
]]></test_output>
<test_input><![CDATA[10 4
sdfsdsassdasdddsasdd
sdasddassdsaadaasdsa
assasaasadassadsaadd
ssasdsaasdassddsassa
saddssassasdsaasssds
dsasdasdsddasdasdssa
asssdasdsasdassdssaa
sadsassdssassdsasssa
sasdsasdsasdsasdsssa
sdsasdsasdsassdasdsa
6
asd
dsa
ads
das
sad
sda
]]></test_input>
<test_output><![CDATA[65
]]></test_output>
<test_input><![CDATA[4 4
dfhfghgdfksgdflsdsds
sdsdsddfsdffssddsfdf
asasassasdsdsdsdsdsd
sadadadasdsdsdsdssdd
4
dssd
dfdfdf
sdsd
jkjjk
]]></test_input>
<test_output><![CDATA[13
]]></test_output>
<test_input><![CDATA[10 4
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaa
1
aaaaa
]]></test_input>
<test_output><![CDATA[193
]]></test_output>
<test_input><![CDATA[2 1
thisisappleisthisthe
oopbooktheisurrtoywe
4
is
of
the
book
]]></test_input>
<test_output><![CDATA[8
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2001年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<cstdio>
#include<cstring>
int word[201][201],dp[201][201][41];
char c[21],w[6][10],c0[201],c1[201];
int d,p,k,s,Max,le[6],len;
int main(){
	int i,j,l,m,yes,x,st;
		scanf("%d%d",&p,&k);
  		for(j=0;j<p;j++){
   			scanf("%s",c);
   			if(!j)strcpy(c0, c);
   			else strcat(c0, c);
  		}
  		len=strlen(c0);
  		scanf("%d",&s);
  		for(j=0;j<s;j++){
   			scanf("%s",w[j]);
   			le[j]=strlen(w[j]);
  		}
  		for(i=0;i<len;i++)for(j=0;j<len;j++)word[i][j]=0; 
  		for(i=len-1;i>=0;i--)for(j=len-1;j>=0;j--){
    			for(l=0;l<s;l++){
     				yes=0;
     				if(c0[j]==w[l][0]&&le[l]<=i-j+1){
      					yes=1; 
      					for(m=0;m<le[l];m++)
       						if(c0[j+m]!= w[l][m]){yes=0;break;}
     				}
     				if(yes==1)break;
    			}
    			if(yes==1)word[j][i]=word[j+1][i]+1; 
    			else word[j][i]=word[j+1][i];
   			}
  		for(st=1;st<=k;st++)for(i=0;i<len-st+1;i++)for(j = i+st-1; j < len; j++){
     				if(st==1){
						dp[i][j][st]=word[i][j]; 
						continue; 
					}
     			for(Max=0,l=i+st-2;l<j;l++){
      				x=dp[i][l][st-1]+word[l+1][j];
      				if(x>Max)Max=x;
     			}
     			dp[i][j][st]=Max;
    			}
  		printf("%d\n",dp[0][len-1][k]);
 	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[{$r-,q-,s-,n+,g+}
const
	maxn = 205;
	maxk = 41;
var
	p,n,k,caseno:integer;
	s,tmps:string[maxn];
	mlen:array[1..maxn] of integer;
	word:array[1..6] of string;
	g:array[0..maxn,0..maxn] of integer;
	h:array[0..maxn,0..maxk] of integer;
	i,j,u,v:Integer;

	begin
		begin
			dec(caseno);
			
			{ init; }
			readln(p,k);
			n:=p*20;
			s:='';
			for i:=1 to p do
			begin
				readln(tmps);
				s:=s+tmps;
			end;
			readln(p);
			for i:=1 to p do
				readln(word[i]);
			
			{ precalc mlen }
			for i:=1 to n do
			begin
				mlen[i]:=maxn;
				for j:=1 to p do
					if( (pos(word[j],copy(s,i,length(s)-i+1))=1) and (length(word[j])<mlen[i]) ) then
						mlen[i]:=length(word[j]);
			end;
				
			{ precalc g }
			for i:=1 to n do
				for j:=1 to n do
				begin
					g[i][j]:=0;
					for u:=i to j do
						if(u+mlen[u]-1<=j) then
							inc(g[i][j]);
				end;
			
			{ Dynamic Programming }
			fillchar(h,sizeof(h),0);
			for j:=1 to k do
				for u:=j to n do
					for v:=u to n do
						if(h[u-1][j-1]+g[u][v]>h[v][j])then
							h[v][j]:=h[u-1][j-1]+g[u][v];
			writeln(h[n][k]);
		end;
		
		close(input);
	
	end.]]></solution>
	</item>
</fps>
