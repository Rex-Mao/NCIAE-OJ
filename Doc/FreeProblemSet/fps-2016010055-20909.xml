<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[旅行家的预算]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站i离出发点的距离Di、每升汽油价格Pi（i=1，2，…，N）。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入数据的第一行输入D1、C、D2、P、N，其中D1、C、D2、P均为浮点数，N为整数。
</p>
<p>
	接下来N行，每行输入两个浮点数表示离出发点的距离Di和每升汽油的价格Pi。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出最小费用，结果四舍五入至小数点后两位。如果无法到达目的地，则输出"No Solution"（引号不输出）。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2]]></sample_input>
<sample_output><![CDATA[26.95]]></sample_output>
  <test_input><![CDATA[199.9 9.0 10.0 99.9 1
100.0 99.9
]]></test_input>
<test_output><![CDATA[No Solution
]]></test_output>
<test_input><![CDATA[475.6 11.9 27.4 14.98 6
102.0 9.99
220.0 13.29
256.3 14.79
275.0 10.29
277.6 11.29
381.8 10.09
]]></test_input>
<test_output><![CDATA[192.15
]]></test_output>
<test_input><![CDATA[87.75 13.03 5.75 7.29 3
22.10 7.38
24.21 6.81
82.08 6.96
]]></test_input>
<test_output><![CDATA[105.95
]]></test_output>
<test_input><![CDATA[99.9 15.9 29.8 99.9 0
]]></test_input>
<test_output><![CDATA[334.90
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 1999年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#define INF 10000000
#define N 1000010
using namespace std;
double ci[N],pi[N];
double dp[N];
int main()
{
    double l,c,m,s;
    int n;
    while(cin>>l>>c>>m>>pi[0]>>n)
    {
        for(int i=1;i<=n;i++)
        {
            scanf("%lf%lf",&ci[i],&pi[i]);
        }
        ci[0]=0,ci[n+1]=l,pi[n+1]=INF;
        s=c*m;
        for(int i=0;i<=n+1;i++)
            dp[i]=INF;
        dp[0]=0;
        int flag=0;
        for(int i=0;i<=n;i++)
        {
            for(int j=i+1;j<=n+1;j++)
            {
                if(s>=ci[j]-ci[i])
                {
                    dp[j]=min(dp[j],dp[i]+pi[i]*(ci[j]-ci[i])/m);
                }
                else
                {
                    if(s>=ci[j]-ci[j-1])
                        dp[j]=min(dp[j],dp[i]+(pi[i]*s+pi[j-1]*(ci[j]-ci[i]-s))/m);
                    else
                    {
                        flag=1;
                        break;
                    }
                }
            }
            if(flag==1)
                break;
        }
        if(dp[n+1]==INF)
            cout<<"No Solution"<<endl;
        else
            printf("%.2lf\n",dp[n+1]);
    }
    return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var
 value,over,way,x:array[0..500]of real;
 l,c,dc,p0,ans:real;
 i,j,n:integer;
begin
 readln(l,c,dc,p0,n);
 for i:=1 to n do
   readln(way[i],value[i]);
 for i:=0 to n do
   begin over[i]:=0;x[i]:=0;end;
 inc(n);way[n]:=l;value[n]:=0;
 i:=0;
 l:=c*dc;
 value[0]:=p0;way[0]:=0;over[0]:=0;
 repeat
   j:=i+1;
   if way[j]-way[i]>l then begin writeln('No Solution');halt end;
   while way[j]-way[i]<=l do
     begin
       if value[j]<value[i] then break;
       inc(j);
     end;
   if way[j]-way[i]<=l then
     if over[i]*dc>=way[j]-way[i] then
       over[j]:=over[i]-(way[j]-way[i])/dc
     else x[i]:=(way[j]-way[i])/dc-over[i]
   else
   begin
     x[i]:=c-over[i];
     j:=i+1;
     over[j]:=c-(way[j]-way[i])/dc;
   end;
   i:=j;
 until i=n;
 ans:=0;
 for i:=0 to n-1 do
   ans:=ans+x[i]*value[i];
 writeln(ans:0:2);
end.]]></solution>
	</item>
</fps>
