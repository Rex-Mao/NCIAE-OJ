<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[最大公约数和最小公倍数问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	输入二个正整数x0，y0（2&lt;=x0&lt;100000，2&lt;=y0&lt;=1000000），求出满足下列条件的P，Q的个数。
</p>
<p>
	条件：
</p>
<p>
	1. P，A是正整数；
</p>
<p>
	2. 要求P，Q以x0为最大公约数，以y0为最小公倍数。
</p>
<p>
	试求：
</p>
<p>
	满足条件的所有可能的两个正整数的个数。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组两个正整数x0和y0<span>（2&lt;=x0&lt;100000，2&lt;=y0&lt;=1000000）</span>。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出<span>满足条件的所有可能的两个正整数的个数。</span> 
</p>
<p>
	<span>下面是对样例数据的说明：</span> 
</p>
<p>
	<span>输入3 60</span> 
</p>
<p>
	<span>此时的P Q分别为:</span> 
</p>
<p>
	<span>&nbsp; &nbsp; 3 &nbsp; &nbsp; 60<br />
&nbsp; &nbsp; 15 &nbsp; 12<br />
&nbsp; &nbsp; 12 &nbsp; 15<br />
&nbsp; &nbsp; 60 &nbsp; 3</span> 
</p>
<p>
	<span>所以，满足条件的所有可能的两个正整数的个数共4种。<br />
</span> 
</p>
<p>
	<span><br />
</span> 
</p>]]></output>
<sample_input><![CDATA[3 60]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <test_input><![CDATA[12 4096
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<test_input><![CDATA[4 1024
]]></test_input>
<test_output><![CDATA[2
]]></test_output>
<test_input><![CDATA[3 999
]]></test_input>
<test_output><![CDATA[4
]]></test_output>
<test_input><![CDATA[12 60
]]></test_input>
<test_output><![CDATA[2
]]></test_output>
<test_input><![CDATA[3 120
]]></test_input>
<test_output><![CDATA[4
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组 2001年NOIP全国联赛普及组]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>

int main()
{
  int x,y,m,i,j,n;
  scanf("%d%d",&x,&y);
  m=x>y?x:y;
  int count=0;
  for(i=2;i<=m;i++)
  {
	  int k=i>x*y/i?x*y/i:i;
	  int h=i>x*y/i?i:x*y/i;
	  for(j=k;j>0;j--)
	  {
	    if((i%j==0)&&(x*y/i%j==0))
			break;
	  }
	  for(n=h;n<=x*y;n++)
	  {
	    if((n%i==0)&&(n%(x*y/i)==0))
			break;
	  }
	  if(j==x&&n==y)
		  count++;
  }
  printf("%d\n",count);
  return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
int g(int n,int m)
{
	int temp,r;
	if(n<m) 
	{ 
		temp=n; 
		n=m; 
		m=temp; 
	} 
	while(m!=0) 
	{ 
		r=n%m; 
		n=m; 
		m=r; 
	} 
	return n;
}
int main()
{
	int a,b,i,j,count;
	while(scanf("%d%d",&a,&b)!=EOF)
	{
		count=0;
		for(i=a;i<=b;i++)
		{
			for(j=i+1;j<=b;j++)
			{
				if(g(i,j)==a&&i*j/g(i,j)==b)
					count++;
			}
		}
		printf("%d\n",2*count);
	}
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var
   x1,x2,i,j,s,y,r,a,b:int64;
begin
 readln(x1,x2);
 s:=0;
 i:=0;
 repeat
  i:=i+x1;
  j:=0;
  repeat
   j:=j+x1;
   a:=j;
   b:=i;
    repeat
     if a<b then
      begin
       r:=a;
       a:=b;
       b:=r;
      end;
     a:=a-b;
    until a=0;
   if (i*j  div x1=x2)and(b=x1)then inc(s);
  until j>=x2;
 until i>=x2 ;
 writeln(s);
end.]]></solution>
	</item>
</fps>
