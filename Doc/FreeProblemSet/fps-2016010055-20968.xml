<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[2^k进制数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	设r是个2<sup>k</sup>进制数，并满足以下条件：
</p>
<p>
	（1）r至少是个2位的2<sup>k</sup>进制数。
</p>
<p>
	（2）作为2<sup>k</sup>进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。
</p>
<p>
	（3）将r转换为2进制数q后，则q的总位数不超过w。
</p>
<p>
	在这里，正整数k（1≤k≤9）和w（k&lt;W≤30000）是事先给定的。
</p>
<p>
	问：满足上述条件的不同的r共有多少个？
</p>
<p>
	我们再从另一角度作些解释：设S是长度为w 的01字符串（即字符串S由w个“0”或“1”组成），S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k 的段，每段对应一位2<sup>k</sup>进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2<sup>k</sup>进制数r。
</p>
<p>
	例：设k=3，w=7。则r是个八进制数（23=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有：
</p>
<p>
	2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，...，高位为6：1个（即67）。共6+5+...+1=21个。
</p>
<p>
	3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，...，第2位为6：1个（即167）。
</p>
<p>
	<span style="line-height:1.5;">共5+4+…+1=15个。</span>
</p>
<p>
	<span style="line-height:1.5;">所以，满足要求的r共有36个。</span>
</p>
<p>
	<span style="line-height:1.5;"><br />
</span>
</p>]]></description>
<input><![CDATA[每组输入数据只有1行，为两个正整数，用一个空格隔开：<br />
<p>
	k W
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[每组输出为1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。<br />
<p>
	<span style="line-height:1.5;">（提示：作为结果的正整数可能很大，但不会超过200位）</span>
</p>
<p>
	<span style="line-height:1.5;"><br />
</span>
</p>]]></output>
<sample_input><![CDATA[3 7]]></sample_input>
<sample_output><![CDATA[36]]></sample_output>
  <test_input><![CDATA[7 4000
]]></test_input>
<test_output><![CDATA[170141183460469231731687303715884105600
]]></test_output>
<test_input><![CDATA[2 8
]]></test_input>
<test_output><![CDATA[4
]]></test_output>
<test_input><![CDATA[3 17
]]></test_input>
<test_output><![CDATA[119
]]></test_output>
<test_input><![CDATA[8 4000
]]></test_input>
<test_output><![CDATA[57896044618658097711785492504343953926634992332820282019728792003956564819712
]]></test_output>
<test_input><![CDATA[4 47
]]></test_input>
<test_output><![CDATA[32631
]]></test_output>
<test_input><![CDATA[5 107
]]></test_input>
<test_output><![CDATA[2135645927
]]></test_output>
<test_input><![CDATA[5 2000
]]></test_input>
<test_output><![CDATA[2147483616
]]></test_output>
<test_input><![CDATA[3 6
]]></test_input>
<test_output><![CDATA[21
]]></test_output>
<test_input><![CDATA[6 107
]]></test_input>
<test_output><![CDATA[4141511146315813
]]></test_output>
<test_input><![CDATA[4 1000
]]></test_input>
<test_output><![CDATA[32752
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组-2006年NOIP全国联赛提高组]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>

int   ans[81]={0};
int a[81]={0};
void mu(int k)
{
   int b[81]={0};
   int i,j;
   for (i=1;i<=a[0];i++) 
   {
     b[i]=b[i-1]/10+a[i]*k;
     b[i-1]=b[i-1]% 10;
   }
   b[0]=a[0];
   while (b[b[0]]]]><![CDATA[>=10)
   {
     b[0]++;
     b[b[0]]=b[b[0]-1]/10;
     b[b[0]-1]=b[b[0]-1] %10;
   }
   for (i=0;i<=b[0];i++)
	   a[i]=b[i];
}
void    divide(int k)
{
   int b[81]={0};
   int i,j,d=0;
   for (i=a[0];i>=1;i--)
   {
     d=d*10+a[i];
     b[i]=d /k;
     d=d% k;
   }
    b[0]=a[0];
   while (b[b[0]]==0)
	   b[0]--;
   for (i=0;i<=80;i++) 
	   a[i]=b[i];
}
void plus1() 
{
   int b[81]={0};
   int len;int i,j;
   if (a[0]>ans[0])
	   len=a[0];
   else
	   len=ans[0];
   for (i=1;i<=len;i++) 
   {
    b[i]=b[i-1]/10+a[i]+ans[i];
    b[i-1]=b[i-1]%10;
   }
   b[0]=len;
   while(b[b[0]]]]><![CDATA[>=10)
   {
    b[0]++;
    b[b[0]]=b[b[0]-1] /10;
    b[b[0]-1]=b[b[0]-1] %10;
   }
   for (i=0;i<=b[0];i++) 
	   ans[i]=b[i];
}
int main()
{
  int i,j,k,m,n;
  int w;
  int jin=1;
  while( scanf("%d%d",&k,&w)!=EOF)
  {
   for (i=1;i<=k;i++) 
	   
	   jin=jin*2;
   int len ;
   len=w /k;
   for (i=2;i<=len;i++) 
   {
     for (j=0;j<=80;j++)
		 a[j]=0;
     a[1]=1;
	 a[0]=1;
     for (j=1;j<=i;j++) 
     {
      mu(jin-j);
      divide(j);
     }
     plus1();
   }
   if (w % k!=0)
   {    
     int tot=1;
     for (j=1;j<=w % k;j++) 
		 tot=tot*2;
     tot=tot-1;
     for (i=tot;i>=1;i--)
        if (jin-i-1>=len)
		{
           for (j=0;j<=80;j++)
			   a[j]=0;
           a[1]=1;a[0]=1;
           for (j=1;j<=len;j++) 
		   {
             mu(jin-i-j);
             divide(j);
		   }
           plus1();
		}
   }
   for (i=ans[0];i>=1;i--) 
	 printf("%d",ans[i]);
   printf("\n");
  }
  
   return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[const  
 maxn=512;   
cifang:array [0..10] of longint=(1,2,4,8,16,32,64,128,256,512,1024);   
   
type  
 arr=array [0..50] of int64;   
  
 var  
 maxlen,n,m:longint;   
f:array [0..1,0..maxn] of arr;   
ans:arr;   
   
procedure init;   
var  
 i:longint;   
begin  
 readln(n,m);   
maxlen:=m div n;   
for i:=cifang[n]-1 downto 1 do  
 begin  
   f[0,i,0]:=1;   
  f[0,i,1]:=1;   
end;   
ans[0]:=1;   
ans[1]:=0;   
end;   
  
 function work(x,y:arr):arr;   
var  
 i,len,t:longint;   
begin  
 t:=0;   
fillchar(work,sizeof(work),0);   
if x[0]>=y[0] then len:=x[0] else len:=y[0];   
work[0]:=len;    
 for i:=1 to len do   
begin  
   work[i]:=x[i]+y[i]+t;   
  t:=work[i] div 1000000000;   
  work[i]:=work[i] mod 1000000000;   
end;   
if t>0 then  
 begin  
   inc(work[0]);   
  work[work[0]]:=t;   
end;   
while (work[work[0]]=0) and (work[0]>1) do dec(work[0]);    
 end;   
  
 procedure main;   
var  
 i,j,t:longint;   
begin  
 for i:=1 to maxlen-1 do  
 begin  
   t:=i mod 2;   
  for j:=cifang[n]-1 downto 1 do  
   begin  
    f[t,j]:=work(f[1-t,j+1],f[t,j+1]);   
   ans:=work(ans,f[t,j]);   
  end;   
end;   
t:=maxlen mod 2;   
if m mod n>0 then  
 begin  
   for j:=cifang[n]-1 downto 1 do  
   begin  
    f[t,j]:=work(f[1-t,j+1],f[t,j+1]);   
   if j<=cifang[m mod n]-1 then ans:=work(ans,f[t,j]);      
   end;   
end;   
end;   
   
procedure print(x:arr);   
var  
 i:longint;   
begin  
 write(x[x[0]]);   
for i:=x[0]-1 downto 1 do  
 begin  
   if x[i]<100000000 then write(0);   
  if x[i]<10000000 then write(0);   
  if x[i]<1000000 then write(0);   
  if x[i]<100000 then write(0);   
  if x[i]<10000 then write(0);   
  if x[i]<1000 then write(0);   
  if x[i]<100 then write(0);   
  if x[i]<10 then write(0);   
  write(x[i]);   
end;   
writeln;   
end;   

begin
 init;   
main;   
print(ans);   
end.]]></solution>
	</item>
</fps>
