<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[虫食算]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp;43#9865#045<br />
&nbsp; &nbsp; + &nbsp; &nbsp; 8468#6633<br />
&nbsp; &nbsp; &nbsp; &nbsp;44445509678<br />
<br />
其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。<br />
<p>
	<span style="line-height:1.5;">现在，我们对问题做两个限制：</span> 
</p>
<p>
	<span style="line-height:1.5;">首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。</span> 
</p>
<p>
	<span style="line-height:1.5;">其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N-1。输入数据保证N个字母分别至少出现一次。</span> 
</p>
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BADC<br />
&nbsp; &nbsp; &nbsp; + &nbsp; &nbsp;CRDA<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DCCC<br />
<br />
<p>
	上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据包含4行。第一行是一个正整数N（N&lt;=26），后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。
</p>
<p>
	<span style="line-height:1.5;"><br />
</span> 
</p>
<p>
	<span style="line-height:1.5;">数据规模：</span> 
</p>
<p>
	对于30％的数据，保证有N&lt;＝10；
</p>
<p>
	对于50％的数据，保证有N&lt;＝15；
</p>
<p>
	对于全部的数据，保证有N&lt;＝26。
</p>
<div>
	<span style="line-height:1.5;"></span> 
</div>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	每组输出包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出<span>N</span>个数字，分别表示<span>A</span>，<span>B</span>，<span>C...</span>所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[5
ABCED
BDACE
EBBAA]]></sample_input>
<sample_output><![CDATA[1 0 3 4 2]]></sample_output>
  <test_input><![CDATA[10
HGCIBAJJCF
BHDAGEEDBE
IEFBEBGEHH
]]></test_input>
<test_output><![CDATA[7 2 0 8 4 9 1 3 5 6
]]></test_output>
<test_input><![CDATA[21
ABCDEFGHIJKLMNOPQRSTU
ABCDEFGHIJKLMNOPQRSTU
ACEGIKMOQTACEGIKMOQST
]]></test_input>
<test_output><![CDATA[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
]]></test_output>
<test_input><![CDATA[15
MFJCGKNDHBALEIO
EBIKIDBMAEELHBC
KGEAOHOJHFFIACJ
]]></test_input>
<test_output><![CDATA[0 1 10 7 3 4 6 12 8 9 5 11 2 13 14
]]></test_output>
<test_input><![CDATA[5
ABCED
BDACE
EBBAA
]]></test_input>
<test_output><![CDATA[1 0 3 4 2
]]></test_output>
<test_input><![CDATA[20
NLHFIEASBRQJOGKMDPCT
NQGPSIIGKDMFDCBFMQSO
PNKNTOLHEIJHFGJKHJGG
]]></test_input>
<test_output><![CDATA[18 14 0 9 15 17 7 13 12 16 1 10 4 2 8 5 11 3 6 19
]]></test_output>
<test_input><![CDATA[18
FQAGNMBECLPOJDHIKR
ADQGABEHFDQADOKPML
LOCOLJFGIRMGJKQCDH
]]></test_input>
<test_output><![CDATA[13 12 4 0 8 3 5 15 7 1 11 16 6 2 10 14 9 17
]]></test_output>
<test_input><![CDATA[12
FDALHECBJKGI
LIKAEDGJBCFH
IJJAFLICDLFE]]></test_input>
<test_output><![CDATA[4 3 9 10 1 7 11 5 8 6 2 0
]]></test_output>
<test_input><![CDATA[21
BADCEFGHIJKLMNOPQRSTU
BADCEFGHIJKLMNOPQRSTU
BDEGIKMOQTBDEGIKMOQST
]]></test_input>
<test_output><![CDATA[1 0 3 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
]]></test_output>
<test_input><![CDATA[8
ABDEBEHG
FGDBBAGB
EDEDCHGE
]]></test_input>
<test_output><![CDATA[2 1 3 7 6 4 5 0
]]></test_output>
<test_input><![CDATA[16
MOBNHFLIKGEJDACP
AKLDNCECMMFBFHJC
PENEMJLFCPJMKJNE
]]></test_input>
<test_output><![CDATA[10 14 1 7 0 5 11 12 3 6 13 9 4 8 2 15
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2004年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,zm[30],c[5][31];
char c1;
bool f[30],F;
bool jc()
{
	int p=0;
	for(int i=n-1;i>=0;--i)
	{
	  if (zm[c[1][i]]==-1||zm[c[2][i]]==-1||zm[c[3][i]]==-1)return false;
	  int x=zm[c[1][i]]+zm[c[2][i]]+p;
	  if(x%n!=zm[c[3][i]])return true;
	  p=x/n;
	}
	return false;
}
bool jc2()
{
	for(int i=n-1;i>=0;--i)//a+b?c
	  if(zm[c[1][i]]!=-1&&zm[c[2][i]]!=-1&&zm[c[3][i]]!=-1)
	  {
		int x=(zm[c[1][i]]+zm[c[2][i]])%n;
		if(!(x%n==zm[c[3][i]]||(x+1)%n==zm[c[3][i]]))return true;
	  }
	for(int i=n-1;i>=0;--i)//a+?=c
	  if(zm[c[1][i]]!=-1&&zm[c[2][i]]==-1&&zm[c[3][i]]!=-1)
	  {
		int x=(zm[c[3][i]]-zm[c[1][i]]+n)%n;
		if(f[x]&&f[(x-1)%n])return true;
	  }
	for(int i=n-1;i>=0;--i)//?+b=c
	  if(zm[c[1][i]]==-1&&zm[c[2][i]]!=-1&&zm[c[3][i]]!=-1)
	  {
		int x=(zm[c[3][i]]-zm[c[2][i]]+n)%n;
		if(f[x]&&f[(x-1)%n])return true;
	  }
	for(int i=n-1;i>=0;--i)//a+b=?
	  if(zm[c[1][i]]!=-1&&zm[c[2][i]]!=-1&&zm[c[3][i]]==-1)
	  {
		int x=(zm[c[1][i]]+zm[c[2][i]])%n;
		if(f[x]&&f[(x+1)%n])return true;
	  }
	return false;
}
void work(int k,int w)
{
	if(F)return;
	if(jc())return;
	if(jc2())return;
	//if(zm[c[1][0]-65]+zm[c[2][0]-65]>n)return;
	if(k==0&&w==3)
	{
	  for(int i=0;i<n-1;++i)printf("%d ",zm[i]);
	  printf("%d\n",zm[n-1]);F=true;return;
	}
	
	
	if(zm[c[w][k]]!=-1)
	{
	  if(w==3){w=1;--k;}else ++w;
	  work(k,w);
	  if(w==1){w=3;++k;}else --w;
	}
	else
	{
	  for(int i=n-1;i>=0;--i)
	    if(!f[i])
	    {
		  zm[c[w][k]]=i,f[i]=true;
		  if(w==3){w=1;--k;}else ++w;
		  work(k,w);
		  if(w==1){w=3;++k;}else --w;
		  zm[c[w][k]]=-1;f[i]=false;
	    }
	}
	
}
int main()
{
	memset(c,0,sizeof(c));
	scanf("%d",&n);
	for(int i=1;i<=3;++i)
	  for(int j=0;j<n;++j)
	    {cin>>c1;c[i][j]=c1-65;}
	F=false;
	memset(f,0,sizeof(f));
	for(int i=0;i<n;++i)zm[i]=-1;
	work(n-1,1);
	return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[var
  a:Array[1..3,1..26]of char;
  b:array['A'..'Z']of longint;
  c:array[0..25]of boolean;
  i,j,n:longint;
function check(x,m:longint):boolean;
var
  yy:boolean;
  i,j:longint;
begin
  if ((b[a[1,x]]+b[a[2,x]]+m)mod n<>b[a[3,x]]) then exit(false);
  for i:=1 to x-1 do
  if (b[a[1,i]]<>-1)and(b[a[2,i]]<>-1)and(b[a[3,i]]<>-1)then
    begin
      yy:=true;
      for j:=0 to 1 do
        if (b[a[1,i]]+b[a[2,i]]+j)mod n=b[a[3,i]] then yy:=false;
      if yy then exit(false);
    end;
  check:=true;
end;
procedure dfs(x,m:longint);
var i,j,d,p,mm:longint;
    aa,bb,cc:boolean;
begin
  if x=0 then
    begin
      if m=0 then
        begin
          for i:=1 to n-1 do write(b[chr(i+64)],' ');
          writeln(b[chr(n+64)]);
          halt;
        end;
      exit;
    end;
  aa:=false;
  bb:=false;
  cc:=false;
  if b[a[1,x]]<>-1 then aa:=true;
  if b[a[2,x]]<>-1 then bb:=true;
  if b[a[3,x]]<>-1 then cc:=true;
  if (aa and bb and cc) then
    begin
      if check(x,m) then dfs(x-1,(m+b[a[1,x]]+b[a[2,x]])div n);
    end
    else if aa and bb then
      begin
        d:=(b[a[1,x]]+b[a[2,x]]+m)mod n;
        if c[d] then
          begin
            b[a[3,x]]:=d;
            c[d]:=false;
            mm:=(b[a[1,x]]+b[a[2,x]]+m)div n;
            if check(x,m) then dfs(x-1,mm);
              c[d]:=true;
              b[a[3,x]]:=-1;
          end;
      end
    else if aa and cc then
  begin
    d:=(b[a[3,x]]-m-b[a[1,x]]+n)mod n;
    if c[d] then
    begin
      b[a[2,x]]:=d;
      c[d]:=false;
      mm:=(d+b[a[1,x]]+m)div n;
      if check(x,m) then dfs(x-1,mm);
      m:=mm;
      c[d]:=true;
      b[a[2,x]]:=-1;
    end;
  end
  else if bb and cc then
    begin
      d:=(b[a[3,x]]-m-b[a[2,x]]+n)mod n;
        if c[d] then
          begin
            b[a[1,x]]:=d;
            c[d]:=false;
            mm:=(d+b[a[2,x]]+m)div n;
            if check(x,m) then dfs(x-1,mm);
            m:=mm;
            c[d]:=true;
            b[a[1,x]]:=-1;
          end;
    end
  else if (not aa)and(not bb)and(not cc) then
    begin
      if a[1,x]<>a[2,x] then
        begin
          for i:=n-1 downto 0 do
            for j:=n-1 downto 0 do
              if (c[i] and c[j])and(i<>j) then
                begin
                  c[i]:=false;
                  c[j]:=false;
                  b[a[1,x]]:=j;
                  b[a[2,x]]:=i;
                  dfs(x,m);
                  c[i]:=true;
                  c[j]:=true;
                  b[a[1,x]]:=-1;
                  b[a[2,x]]:=-1;
                end;
    end
else
for i:=n-1 downto 0 do
if c[i] then
begin
  b[a[1,x]]:=i;
  c[i]:=false;
  dfs(x,m);
  b[a[p,x]]:=-1;
  c[i]:=true;
end;
end
else begin
  for i:=n-1 downto 0 do
  if c[i] then
    begin
      if not aa then p:=1
      else if not bb then p:=2
      else if not cc then p:=3;
      b[a[p,x]]:=i;
      c[i]:=false;
      dfs(x,m);
      b[a[p,x]]:=-1;
      c[i]:=true;
    end;
      end;
end;
begin
  readln(n);
  for i:=1 to 3 do
    begin
      for j:=1 to n do
        read(a[i,j]);
      readln;
    end;
  fillchar(b,sizeof(b),255);
  fillchar(c,sizeof(c),true);
  dfs(n,0);
end.
]]></solution>
	</item>
</fps>
