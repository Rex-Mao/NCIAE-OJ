<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[计算器的改良]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[NCL是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手ZL先生。为了很好的完成这个任务，ZL先生首先研究了一些一元一次方程的实例：<br />
<br />
&nbsp; &nbsp;4+3x=8<br />
&nbsp; &nbsp;6a-5+1=2-2a<br />
-5+12y=0<br />
<br />
<p>
	ZL先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及+、-、=这三个数学符号（当然，符号"─"既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。
</p>
<p>
	<br />
</p>
<p>
	编写程序，解输入的一元一次方程，将解方程的结果（精确至小数点后三位）输出至屏幕。<br />
<span style="line-height:1.5;">你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。</span>
</p>
<div>
	<br />
</div>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入一个字符串，表示一个一元一次方程。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，<span>解方程的结果（精确至小数点后三位）输出至屏幕。</span> 
</p>
<p>
	<span><br />
</span> 
</p>]]></output>
<sample_input><![CDATA[6a-5+1=2-2a]]></sample_input>
<sample_output><![CDATA[a=0.750]]></sample_output>
  <test_input><![CDATA[-25a+18-2=-7a-2
]]></test_input>
<test_output><![CDATA[a=1.000
]]></test_output>
<test_input><![CDATA[20+3x=-18
]]></test_input>
<test_output><![CDATA[x=-12.667
]]></test_output>
<test_input><![CDATA[-a+1a-3=a-3
]]></test_input>
<test_output><![CDATA[a=0.000
]]></test_output>
<test_input><![CDATA[-6+12x=0
]]></test_input>
<test_output><![CDATA[x=0.500
]]></test_output>
<test_input><![CDATA[47-2=6y+3
]]></test_input>
<test_output><![CDATA[y=7.000
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组 2000年NOIP全国联赛普及组]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <cstdio>

using namespace std;

int main() {
    
    int nums[2] = {0}, letters[2] = {0};
    char ch, le;
    int nownum = 0, negative = 1, lr = 0;
    
    while(cin >> ch) {
        if (ch == '=') {
            lr = 1;
            nums[0] += negative * nownum;
            nownum = 0; negative = 1;
        } else if (ch == '-') {
            nums[lr] += negative * nownum;
            nownum = 0; negative = -1;
        } else if (ch == '+') {
            nums[lr] += negative * nownum;
            nownum = 0; negative = 1;
        } else if (ch >= 'a' && ch <= 'z') {
            le = ch;
            letters[lr] += negative * nownum;
            nownum = 0; negative = 1;
        } else {
            nownum *= 10; nownum += ch - '0';
        }
    }
    
    nums[lr] += negative * nownum;
    
    int num = nums[1] - nums[0], letter = letters[0] - letters[1];
    
    printf("%c=%.3f\n", le, (num * 1.0 / (letter * 1.0)));
    
    return 0;
    
}]]></solution>
			<solution language="Pascal"><![CDATA[var s,left,right,letter:ansistring;
    i,j,x,left_ans,right_ans,left_num,right_num:longint;
begin
  readln(s);
  x:=pos('=',s);
  left:=copy(s,1,x-1);
  right:=copy(s,x+1,length(s)-x);
  x:=0;
  for i:=1 to length(left) do
    begin
      if (left[i]>='a')and(left[i]<='z')or(left[i]>='A')and(left[i]<='Z') then
        if (x=0) then
          begin
            if (i<>length(left))and((not((left[i+1]>='a')
               and(left[i+1]<='z')or(left[i+1]>='A')
             and(left[i+1]<='Z')))) then
               begin
                 for j:=i-1 downto 2 do
                   if not((left[j-1]>='0')and(left[j-1]<='9')) then break;
                 if left[j]='-' then left_num:=left_num-1
                 else inc(left_num);
                 x:=0;
                 continue;
               end;
          end
        else
          begin
            if (i<>length(left))and((not((left[i+1]>='a')and(left[i+1]<='z')
               or(left[i+1]>='A')
             and(left[i+1]<='Z')))) then
               begin
                 for j:=i-1 downto 1 do
                   if (left[j]='-')or(left[j]='+') then break;
                 if left[j]='-' then left_num:=left_num-x
                 else left_num:=left_num+x;
                 x:=0;
                 continue;
               end;
          end;
      if (left[i]>='0')and(left[i]<='9') then x:=x*10+ord(left[i])-48;
      if (left[i]='-')or(left[i]='+') then
        begin
          if (i<>1)and(not((left[i-1]>='a')and(left[i-1]<'z')or
             (left[i-1]>='A')and(left[i-1]<='Z'))) then
               begin
                 for j:=i-1 downto 1 do
                   if (left[j]='-')or(left[j]='+') then break;
                 if left[j]='-' then left_ans:=left_ans-x
                 else left_ans:=left_ans+x;
                 x:=0;
               end;
        end;
    end;
  for i:=length(left) downto 1 do
    if (left[i]='-')or(left[i]='+') then break;
  if (left[i]='-') then
    begin
      if (left[length(left)]>='0')and(left[length(left)]<='9') then
         left_ans:=left_ans-x
      else
        begin
          if x<>0 then left_num:=left_num-x
          else left_num:=left_num+1;
        end;
    end
  else
      if (left[length(left)]>='0')and(left[length(left)]<='9') then
         left_ans:=left_ans+x
      else
        begin
          if x<>0 then left_num:=left_num+x
          else left_num:=left_num+1;
        end;
  x:=0;
  for i:=1 to length(right) do
    begin
      if (right[i]>='a')and(right[i]<='z')or(right[i]>='A')and(right[i]<='Z')
        then
        if (x=0) then
          begin
            if (i<>length(right))and((not((right[i+1]>='a')
               and(right[i+1]<='z')or(right[i+1]>='A')
             and(right[i+1]<='Z')))) then
               begin
                 for j:=i-1 downto 2 do
                   if not((right[j-1]>='0')and(right[j-1]<='9')) then break;
                 if right[j]='-' then right_num:=right_num-1
                 else inc(right_num);
                 x:=0;
                 continue;
               end;
          end
        else
          begin
            if (i<>length(right))and((not((right[i+1]>='a')
               and(right[i+1]<='z')or(right[i+1]>='A')
             and(right[i+1]<='Z')))) then
               begin
                 for j:=i-1 downto 1 do
                   if (right[j]='-')or(right[j]='+') then break;
                 if right[j]='-' then right_num:=right_num-x
                 else right_num:=right_num+x;
                 x:=0;
                 continue;
               end;
          end;
      if (right[i]>='0')and(right[i]<='9') then x:=x*10+ord(right[i])-48;
      if (right[i]='-')or(right[i]='+') then
        begin
          if (i<>1)and(not((right[i-1]>='a')and(right[i-1]<'z')or
             (right[i-1]>='A')and(right[i-1]<='Z'))) then
               begin
                 for j:=i-1 downto 1 do
                   if (right[j]='-')or(right[j]='+') then break;
                 if right[j]='-' then right_ans:=right_ans-x
                 else right_ans:=right_ans+x;
                 x:=0;
               end;
        end;
    end;
  for i:=length(right) downto 1 do
    if (right[i]='-')or(right[i]='+') then break;
  if (right[i]='-') then
    begin
      if (right[length(right)]>='0')and(right[length(right)]<='9') then
        right_ans:=right_ans-x
      else
        begin
          if x<>0 then right_num:=right_num-x
          else right_num:=right_num+1;
        end;
    end
  else
      if (right[length(right)]>='0')and(right[length(right)]<='9') then
        right_ans:=right_ans+x
      else
        begin
          if x<>0 then right_num:=right_num+x
          else right_num:=right_num+1;
        end;
  for i:=1 to length(s) do
    if (s[i]>='A')and(s[i]<='Z')or(s[i]>='a')and(s[i]<='z') then
      begin
        j:=i;
        while (j<=length(s))and(s[j]>='A')and(s[j]<='Z')or(s[j]>='a')
              and(s[j]<='z') do
          begin
            letter:=letter+s[j];inc(j);
          end;
        break;
      end;
  writeln(letter,'=',(left_ans+(-right_ans))/(right_num+(-left_num)):0:3);
end.]]></solution>
	</item>
</fps>
