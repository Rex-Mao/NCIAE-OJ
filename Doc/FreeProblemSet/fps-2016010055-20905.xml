<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[回文数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。<br />
例如：给定一个10进制数56，将56加56（即把56从右向左读），得到121是一个回文数。<br />
又如：对于10进制数87：<br />
&nbsp; &nbsp; STEP1：87+78 &nbsp;= 165 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STEP2：165+561 = 726<br />
&nbsp; &nbsp; STEP3：726+627 = 1353 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STEP4：1353+3531 = 4884<br />
在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884。<br />
<br />]]></description>
<input><![CDATA[<p>
	每个测试文件只包含一组测试数据，每组输入一个N（<span>2&lt;=N&lt;=10，N=16</span>）进制数M，每组的第一行输入N，第二行输入M。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	对于每组输入数据，输出<span>最少经过几步可以得到回文数。如果在30步以内（包含30步）不可能得到回文数，则输出"Impossible!"。</span> 
</p>
<p>
	<span><br />
</span> 
</p>]]></output>
<sample_input><![CDATA[9
87]]></sample_input>
<sample_output><![CDATA[STEP=6]]></sample_output>
  <test_input><![CDATA[2
10011
]]></test_input>
<test_output><![CDATA[STEP=4
]]></test_output>
<test_input><![CDATA[16
AC27
]]></test_input>
<test_output><![CDATA[STEP=6
]]></test_output>
<test_input><![CDATA[10
89
]]></test_input>
<test_output><![CDATA[STEP=24
]]></test_output>
<test_input><![CDATA[2
101111
]]></test_input>
<test_output><![CDATA[Impossible!
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组 1999年NOIP全国联赛普及组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string.h>
using namespace std;
const int Max = 5000;
int len,d,lim=30;
char str[Max],rts[Max];

void fz(char a[Max],char b[Max])
{
    for (int i=0;i<len;++i)
        a[i] = b[len-1-i];
}

void add()
{
    int c = 0;
    for (int i=0;i<len;++i)
    {
         rts[i] += str[i] - '0' + c;
         c = (rts[i] - '0')/d;
         rts[i] = (rts[i] - '0')%d + '0';
    }
	if (c) rts[len] = '0' + c;
}

bool judge()
{
    for (int i = 0;i<len;++i)
        if (rts[i]!=rts[len-1-i]) return 0;
    return 1;
}

int main()
{
    cin>>d>>str;
    int i ;
	for (i=0;i<strlen(str);++i)
	{
		if ('A'<=str[i] && str[i]<='Z')
			str[i] = str[i] - 'A' + '9' + 1;
	}
    for (i=0;i<=lim;++i)
    {
        len = strlen(str);
        fz(rts,str);if (judge()==1) break;
        add();
        len = strlen(rts);     
        fz(str,rts);
	//    cout<<str<<endl;
    }
    if (i<=lim) cout<<"STEP="<<i<<endl;
    else cout<<"Impossible!"<<endl;
}]]></solution>
			<solution language="Pascal"><![CDATA[var s,s1:string;n,t,i,l:longint;x,y:array[1..100]of integer;flag:boolean;
begin
  readln(n);
  readln(s);
  t:=0;
  repeat
    inc(t);
    s1:='';
    for i:=length(s) downto 1 do
      s1:=s1+s[i];
    if n=16 then
      begin
        fillchar(x,sizeof(x),0);
        fillchar(y,sizeof(y),0);
        for i:=1 to length(s) do
          if s[i]>='A' then x[i]:=ord(s[length(s)+1-i])-ord('A')+10
          else x[i]:=ord(s[length(s)+1-i])-48;
        for i:=1 to length(s1) do
          if s1[i]>='A' then y[i]:=ord(s1[length(s1)+1-i])-ord('A')+10
          else y[i]:=ord(s1[length(s1)+1-i])-48;
        for i:=1 to length(s) do
          begin
            x[i]:=x[i]+y[i];
            x[i+1]:=x[i+1]+x[i] div 16;
            x[i]:=x[i] mod 16;
          end;
        if x[length(s)+1]<>0 then l:=length(s)+1
        else l:=length(s);
        s:='';
        for i:=l downto 1 do
          if x[i]>=10 then s:=s+chr(ord('A')+x[i]-10)
          else s:=s+chr(x[i]+48);
      end
    else
      begin
        fillchar(x,sizeof(x),0);
        fillchar(y,sizeof(y),0);
        for i:=1 to length(s) do
          x[i]:=ord(s[length(s)+1-i])-48;
        for i:=1 to length(s1) do
          y[i]:=ord(s1[length(s1)+1-i])-48;
        for i:=1 to length(s) do
          begin
            x[i]:=x[i]+y[i];
            x[i+1]:=x[i+1]+x[i] div n;
            x[i]:=x[i] mod n;
          end;
        if x[length(s)+1]<>0 then l:=length(s)+1
        else l:=length(s);
        s:='';
        for i:=l downto 1 do
          s:=s+chr(x[i]+48);
      end;
    flag:=true;
    for i:=1 to length(s) div 2 do
      if s[i]<>s[length(s)+1-i] then
        begin
          flag:=false;
          break;
        end;
    if flag then
      begin
        writeln('STEP=',t);
        halt;
      end;
  until t=30;
  writeln('Impossible!');
end.]]></solution>
	</item>
</fps>
