<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[同余方程（Day 2）]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	求关于x的同余方程ax≡1(mod b)的最小正整数解。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据只有一行，包含两个正整数a, b，用一个空格隔开。
</p>
<p>
	<br />
</p>
<p>
	数据规模：
</p>
<p>
	<span style="line-height:1.5;">对于40%的数据，2≤b≤1,000；</span>
</p>
<p>
	对于60%的数据，2≤b≤50,000,000；
</p>
<p>
	对于100%的数据，2≤a, b≤2,000,000,000。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	每组输出只有一行，包含一个正整数x<sub>0</sub>，即最小正整数解。输入数据保证一定有解。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[3 10]]></sample_input>
<sample_output><![CDATA[7]]></sample_output>
  <test_input><![CDATA[1121324517 2000000000
]]></test_input>
<test_output><![CDATA[1746511853
]]></test_output>
<test_input><![CDATA[26747 47232425
]]></test_input>
<test_output><![CDATA[23454633
]]></test_output>
<test_input><![CDATA[86940520 376534211
]]></test_input>
<test_output><![CDATA[183549018
]]></test_output>
<test_input><![CDATA[1420590574 1783828399
]]></test_input>
<test_output><![CDATA[1038716345
]]></test_output>
<test_input><![CDATA[137188 19982465
]]></test_input>
<test_output><![CDATA[2709667
]]></test_output>
<test_input><![CDATA[7 10

]]></test_input>
<test_output><![CDATA[3
]]></test_output>
<test_input><![CDATA[1994182834 1487268523
]]></test_input>
<test_output><![CDATA[977649103
]]></test_output>
<test_input><![CDATA[233 1000
]]></test_input>
<test_output><![CDATA[897
]]></test_output>
<test_input><![CDATA[71 32
]]></test_input>
<test_output><![CDATA[23
]]></test_output>
<test_input><![CDATA[178 341
]]></test_input>
<test_output><![CDATA[182
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组-2012年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int d,x,y;
void exgcd(int a,int b)
{
	if(!b){d=a;x=1;y=0;}
	else {exgcd(b,a%b);
	int t=x;x=y;y=t-a/b*y;}
}
int main()
{
    int a,n;
    cin>>a>>n;exgcd(a,n);
    x%=n;while(x<0)x+=n;
    cout<<x;
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var a,b,x,y,k:longint;
function ex(a,b:longint; var x,y:longint):longint;
var t:longint;
begin
  if b=0 then
  begin x:=1;y:=0;exit(a);end;
  ex:=ex(b,a mod b,x,y);
  t:=x;
  x:=y;
  y:=t-(a div b)*y;
end;
begin
  readln(a,b);
  k:=ex(a,b,x,y);
  writeln((x+b)mod b);
end.
]]></solution>
			<solution language="Java"><![CDATA[
import java.util.Scanner;

class data_{
	int x;
	int y;
}
public class Main {
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		int a=cin.nextInt();
		int b=cin.nextInt();
		data_ da=new data_();
		int d=exGcd(a,b,da);
//		da.x+ny=0;
		if (da.x<0) {
			int ans=-da.x%b==0?0:(-da.x/b+1)*b+da.x;
			System.out.println(ans);
		}
		else {
			System.out.println(da.x);
		}
	}
	public static int exGcd(int a,int b,data_ d) {  
		if(b==0)   
		{    
			d.x=1;d.y=0;   
			return a;   
		 }   
		int r=exGcd(b,a%b,d);  
		int t=d.x;
		d.x=d.y;
		d.y=t-a/b*d.y;   
		return r; 
		} 
}
]]></solution>
	</item>
</fps>
