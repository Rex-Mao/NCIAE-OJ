<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[等价表达式]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。
</p>
<p>
	这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？
</p>
<p>
	这个选择题中的每个表达式都满足下面的性质：
</p>
<p>
	1．表达式只可能包含一个变量‘a’。
</p>
<p>
	2．表达式中出现的数都是正整数，而且都小于10000。
</p>
<p>
	3．表达式中可以包括四种运算‘+’（加），‘-’（减），‘*’（乘），‘^’（乘幂），以及小括号‘(’，‘)’。小括号的优先级最高，其次是‘^’，然后是‘*’，最后是‘+’和‘-’。‘+’和‘-’的优先级是相同的。相同优先级的运算从左到右进行。（注意：运算符‘+’，‘-’，‘*’，‘^’以及小括号‘(’，‘)’都是英文字符）
</p>
<p>
	4．幂指数只可能是1到10之间的正整数（包括1和10）。
</p>
<p>
	5．表达式内部，头部或者尾部都可能有一些多余的空格。
</p>
<p>
	下面是一些合理的表达式的例子：
</p>
<p>
	((a^1) ^ 2)^3，a*a+a-a，((a+a))，9999+(a-a)*a，1 + (a -1)^3，1^10^9...
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	每组输入数据的第一行给出的是题干中的表达式。第二行是一个整数n（2&lt;=n&lt;=26），表示选项的个数。后面n行，每行包括一个选项中的表达式，表达式中没有空格。这n个选项的标号分别是A，B，C，D...
</p>
<p>
	输入中的表达式的长度都不超过50个字符，而且保证选项中总有表达式和题干中的表达式是等价的。
</p>
<p>
	<span style="line-height:1.5;"><br />
</span> 
</p>
<p>
	<span style="line-height:1.5;">数据规模：</span> 
</p>
<p>
	<span style="line-height:1.5;">对于30%的数据，表达式中只可能出现两种运算符‘+’和‘-’；</span> 
</p>
<p>
	<span style="line-height:1.5;">对于其它的数据，四种运算符‘+’，‘-’，‘*’，‘^’在表达式中都可能出现。</span> 
</p>
<p>
	<span style="line-height:1.5;">对于全部的数据，表达式中都可能出现小括号‘(’和‘)’。</span> 
</p>
<p>
	<span style="line-height:1.5;"><br />
</span> 
</p>
<p>
	<span style="line-height:1.5;"></span> 
</p>]]></input> 
<output><![CDATA[<p>
	每组输出包括一行，这一行包括一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[(a+1)^2
3
(a-1)^2+4*a
a+1+a
a^2+2*a*1+1^2+10-10+a-a]]></sample_input>
<sample_output><![CDATA[AC]]></sample_output>
  <test_input><![CDATA[1-(a^8-1)*1*(a^8+1)*1*1*1*1*1*(1-2)-1
26
(2^10^10-(2048^9*2)-9+6^1)^2
9999+9999+9999+9999-(9999+9999+9999+9999)+a+5
(a+1+5)*(a^2+1^2+5^2-(1-2*a*1-1)+2*5*(a+1))
((a+1)-a-8-7-(1-(8+7))-(9999-9990)-3
1-2*a^1+3*a^2-4*a^3+5*a^4-a^5*(6-7*a+8*a^2-9*a^3)
(7+8)^4-(8*8^3*7+2^3*8*7^3)
(a^8+1)^2-2*(1+a^8)
(a+3*(1+5))*a^2+((1+5)*2*(1+5)+(1+5)^2)*a+(1+5)^3
(6^2-2*6*9+9^1*9^1)^5
((6+9)^2-4*6*9))^5+(6-6)^10^10^10^10^10^10
(6^3-3*6*9*(6-9)-9^3)^4^8*(6^2-2*6*9+9^2)^2
9999+(9-8)*8
a^2^2^2^2-1
6^10^10+2-1
a^2^2^2^2^2-1
6-6+1+(6-6)^10^7
(1-a)^2+2*a^2-4*a^3+5*a^4-6*a^5+7*a^6-8*a^7+9*a^8
7*7*7*7+8*8*8*8+4*8*7*(1-1-(8*8+7*7))+6*8*7*8*7
(7-8)*(8-7)*(7-8)*(7-8)
(a+1)^3+3*(a+1)^2*5+3*(a+1)*5*5+(a+1)^3^1
9999^9^9-9^9^9*1111^9^9-(1-a^8)*(1+a^8)+9
a-(a+1)+1+1+5+12-12+6-6+a-(8-8)
1023+a+5-1022
6-(6-(9-(9-(8-(5+8)))))-(a-5)+a+1+5+a
9999+6^10^10-11*101*9-6^2^5^5^2-(1-a-1-5-1)^3
6^10^10-9^10^10+1
]]></test_input>
<test_output><![CDATA[GM
]]></test_output>
<test_input><![CDATA[10-9+8-7-((5+(4+3+1-(1-2))))
8
9+9+4+6+9+1-9-5-1-(8-7)
9999+9999+9999+9999-(9999+9999+9999+9999)+1+8
1-13
6
((1+5)-1-8-7-(5-(8+7))-(9999-9990)-3
6+9+8+5+9+2+4+1+8+3+9+3+8+3+7+8-6-8+9+4+1+1+7+6+1
1-1-1-1-1-1-1-1-1-1-1-1-1-1
12
]]></test_input>
<test_output><![CDATA[CEG
]]></test_output>
<test_input><![CDATA[a-a+1+(9-9)^2^9
26
(2^10*4-(2048*2)-9+6^1)^3
9999+9999+9999+9999-(9999+9999+9999+9999)+6+5
(6+1+5)*(6^2+1^2+5^2-(1-2*6*1-1)+2*5*(6+1))
((6+1)-6-3-8-(1-(3+8))-(9999-9990)-3
(8-3)^4
1-2*6^1+3*6^2-4*6^3+5*6^4-6^5*(6-7*6+8*6^2-9*6^3)
(8+3)^4-(8*3^3*8+2^3*3*8^3)
(6+3*(1+5))*6^2+((1+5)*2*(1+5)+(1+5)^2)*6+(1+5)^3
(a^2-2*a*6+6^1*6^1)^4
((a+6)^2-4*a*6))^2 +(a-a)^9
(a^3-3*a*6*(a-6)-6^3)^9*(a^2-2*a*6+6^2)^2
9999+(6-9)*6
1+(3-8)^3
a^10^7+2-1
a-1+2
1
a-a+1+(a-a)^7
(1-6)^2+2*6^2-4*6^3+5*6^4-6*6^5+7*6^6-8*6^7+9*6^8
8*8*8*8+3*3*3*3+4*3*8*(1-1-(3*3+8*8))+6*3*8*3*8
(8-3)*(3-8)*(8-3)*(8-3)
(6+1)^3+3*(6+1)^2*5+3*(6+1)*5*5+(6+1)^3^1
6-(6+1)+1+1+5+12-12+a-a+6-(3-3)
1023+6+5-1022
a-(a-(6-(6-(9-(8+9)))))-(6-8)+6+1+5+6
9999+a^10^10-11*101*9-a^2^5^5^2-(1-6-1-5-1)^3
a^10^10-6^2+1
]]></test_input>
<test_output><![CDATA[PQ
]]></test_output>
<test_input><![CDATA[a^4-4*a^3*8+6*a^2*8^2-4*a*8^3+8^4
26
(2^10*4-(2048*2)-9+6^1)^3
9999+9999+9999+9999-(9999+9999+9999+9999)+6+5
(6+1+5)*(6^2+1^2+5^2-(1-2*6*1-1)+2*5*(6+1))
((6+1)-6-a-8-(1-(a+8))-(9999-9990)-3
6+9+8+5+9+2+4+1+8+3+9+3+a+3+8+7-8-6+8+9+4+1+1+7+6
1-1-1-1-1-1-1-1-1-1-1-1-1-1
((6^1)^2)^3
(8-a)^4
(8+a)^4-(8*a^3*8+2^3*a*8^3)
(6+3*(1+5))*6^2+((1+5)*2*(1+5)+(1+5)^2)*6+(1+5)^3
(6^2-2*6*9+9^1*9^1)^3
((6+9)^2-4*6*9))^7+(6-6)^10
(6^3-3*6*9*(6-9)-9^3)^5*(6^2-2*6*9+9^2)^2
9999+(9-8)*6
1+(a-8)^3
9^3^3
((6+1+5))
1+5+6
8*8*8*8+a*a*a*a+4*a*8*(1-1-(a*a+8*8))+6*a*8*a*8
(8-a)*(a-8)*(8-a)*(8-a)
(6+1)^3+3*(6+1)^2*5+3*(6+1)*5*5+(6+1)^3^1
6+6+1+1+5+6
6-(6+1)+1+1+5+12-12+6-6+6-(a-a)
1023+6+5-1022
6-(6-(9-(9-(8-(5+8)))))-(6-5)+6+1+5+6
9999+6^10-11*101*9-6^2^5-(1-6-1-5-1)^3
]]></test_input>
<test_output><![CDATA[HIS
]]></test_output>
<test_input><![CDATA[(a+1+5)^3
26
9+9+4+6+9+1-9-5-1-(8-7)
9999+9999+9999+9999-(9999+9999+9999+9999)+a+5
1-13
(a+1+5)*(a^2+1^2+5^2-(1-2*a*1-1)+2*5*(a+1))
6
((a+1)-a-8-7-(1-(8 +7))-(9999-9990)-3
6+9+8+5+9+2+4+1+8+3+9+3+8+3+7+8-6-8+9+4+1+1+7+6+a
1-1-1-1-1-1-1-1-1-1-1-1-1-1
12
10+7
7+10
((6^1)^2)^3
(a+3*(1+5))*a^2+((1+5)*2*(1+5)+(1+5)^2)*a+(1+5)^3
6*9+6-6
((6+9))
9999+(9-8)*8
1+(8-7)^3
4^10
((a+1+5))
1+5+a
(a+1)^3+3*(a+1)^2*5+3*(a+1)*5*5+(a+1)^3^1
a+a+1+1+5+6
a-(a+1)+1+1+5+12-12+6-6+a-(8-8)
1023+a+5-1022
6-(6-(9-(9-(8-(5+8)))))-(a-5)+a+1+5+a
9999+6^1^10-11*101*9-6^2^5-(1-a-1-5-1)^3
]]></test_input>
<test_output><![CDATA[DMZ
]]></test_output>
<test_input><![CDATA[1-a*(2-a*(3-a*(4-a*(5-a*(6-a*(7-a*(8-a*9)))))))
26
(2^10*4-(2048*2)-9+6^1)^3
1-2*a^1+3*a^2-4*a^3+5*a^4-6*a^5+7*a^6-8*a^7+9*a^8
9999+9999+9999+9999-(9999+9999+9999+9999)+a+5
(a+1+5)*(a^2+1^2+5^2-(1-2*a*1-1)+2*5*(a+1))
((a+1)-a-8-7-(1-(8+7))-(9999-9990)-3
6+9+8+5+9+2+4+1+8+3+9+3+8+3+7+8-6-8+9+4+1+1+7+6+a
((6^1)^2)^3
(7-8)^4
1-2*a^1+3*a^2-4*a^3+5*a^4-a^5*(6-7*a+8*a^2-9*a^3)
(7+8)^4-(8*8^3*7+2^3*8*7^3)
(a+3*(1+5))*a^2+((1+5)*2*(1+5)+(1+5)^2)*a+(1+5)^3
(6^2-2*6*9+9^1*9^1-10)^5^10
((6+9)^2-4*6*9)-10)^10^5+(6-6)^10^10^10^10^10
(6^3-3*6*9*(6-9)-9^3+28)^4^8*(6^2-2*6*9+9^2)^2
9999+(9-8)*8
1+(8-7)^3
4^7
(1-a)^2+2*a^2-4*a^3+5*a^4-6*a^5+7*a^6-8*a^7+9*a^8
7*7*7*7+8*8*8*8+4*8*7*(1-1-(8*8+7*7))+6*8*7*8*7
(7-8)*(8-7)*(7-8)*(7-8)
(a+1)^3+3*(a+1)^2*5+3*(a+1)*5*5+(a+1)^3^1
a-(a+1)+1+1+5+12-12+6-6+a-(8-8)
1023+a+5-1022
6-(6-(9-(9-(8-(5+8)))))-(a-5)+a+1+5+a
9999+6^10-11*101*9-6^2^5-(1-a-1-5-1)^3
6-2*a^1+3*a^2-4*a^3+5*a^4-6*a^5+7*a^6-8*a^7+9*a^8
]]></test_input>
<test_output><![CDATA[BIR
]]></test_output>
<test_input><![CDATA[a+(1+5)
8
((a+1+5))
1+5+a
a+a+1+1+5+6
a-(a+1)+1+1+5+12-12+6-6+a-(8-8)
1023+a+5-1022
6-(6-(9-(9-(8-(5+8)))))-(a-5)+a+1+5+a
9+9+4+6+9+1-9-5-1-(8-7)
9999+9999+9999+9999-(9999+9999+9999+9999)+a+5
]]></test_input>
<test_output><![CDATA[ABDEF
]]></test_output>
<test_input><![CDATA[(a-6)^10^10
26
(2^10^10-(2048^9 *2)-6+a^1)^2^5^2^5
6+6+9+8+3+1-5-8-1-(9-8)
9999+9999+9999+9999-(9999+9999+9999+9999)+6+5
(6+1+5)*(6^2+1^2+5^2-(1-2*6*1-1)+2*5*(6+1))
a
((6+1)-6-3-8-(1-(3+8))-(9999-9990)-3
a+6+9+8+5+9+2+4+1+8+3+9+3+9+8+7-8-6+8+9+4+1+1+7+6
1-1-1-1-1-1-1-1-1-1-1-1-1-1
((a^1)^2)^3
(6+3*(1+5))*6^2+((1+5)*2*(1+5)+(1+5)^2)*6+(1+5)^3
a*6+8-a
((a+6))
(a^2-2*a*6+6^1*6^1)^5^10
((a+6)^2-4*a*6))^10^5+(a-a)^10^10^10^10^10^10
(a^3-3*a*6*(a-6)-6^3)^4^8 *(a^2-2*a*6+6^2)^2
9999+(6-9)*6
1+(3-8)^3
9^10^9
((6+1+5))
1+5+6
(6+1)^3+3*(6+1)^2*5+3*(6+1)*5*5+(6+1)^3^1
6+6+1+1+5+a
6-(6+1)+1+1+5+12-12+a-a+6-(3-3)
1023+6+5-1022
a-(a-(6-(6-(9-(8+9)))))-(6-8)+6+1+5+6
9999+a^10^10-11*101*9-a^2^5^5^2-(1-6-1-5-1)^3
]]></test_input>
<test_output><![CDATA[AMNO
]]></test_output>
<test_input><![CDATA[10+(1-a)+(a+8)-(9-8)
10
9+9+9+8+9+1-9-5-1-(8-8)
9999+9999+9999+9999-(9999+9999+9999+9999)+6+5
1-13
6
((6+1)-6-a-8-(1-(a+8))-(9999-9990)-3
6+9+8+5+9+2+4+1+8+3+9+3+a+3+8+7-8-6+8+9+4+1+1+7+6
1-1-1-1-1-1-1-1-1-1-1-1-1-1
12
10+8
8+10
]]></test_input>
<test_output><![CDATA[IJ
]]></test_output>
<test_input><![CDATA[(1000+24)^3*8*a*6^6*9*(3*a^2+4*9^2)*(a^2+12*9^2)
26
(2^10*4-(2048*2)-9+6^1)^3
9999+9999+9999+9999-(9999+9999+9999+9999)+6+5
(6+1+5)*(6^2+1^2+5^2-(1-2*6*1-1)+2*5*(6+1))
((6+1)-6-3-8-(1-(3+8))-(9999-9990)-3
1-2*6^1+3*6^2-4*6^3+5*6^4-6^5*(6-7*6+8*6^2-9*6^3)
(8+3)^4-(8*3^3*8+2^3*3*8^3)
(6^8+1)^2-2*(1+6^8)
(6+3*(1+5))*6^2+((1+5)*2*(1+5)+(1+5)^2)*6+(1+5)^3
(a^2-2*a*6+6^1*6^1)^5
((a+6)^2-4*a*6))^5 +(a-a)^10^7
(a^3-3*a*6*(a-6)-6^3)^4^8*(a^2-2*a*6+6^2)^2
9999+(6-9)*6
6^2^2-1
a^10^10+2-1
6^2^2^2-1
a-a+1+(a-a)^10^9^8^7^6^5^4^3^2
(1-6)^2+2*6^2-4*6^3+5*6^4-6*6^5+7*6^6-8*6^7+9*6^8
8*8*8*8+3*3*3*3+4*3*8*(1-1-(3*3+8*8))+6*3*8*3*8
(8-3)*(3-8)*(8-3)*(8-3)
2^5^6*(7*a*6^6*9*(3*a^2+4*9^2)*(a^2+12*9^2))
2^5^6*(4*a*6^6*9*(3*a^2+8*9^2)*(a^2+12*9^2))
2^5^6*(24*a^5*6^6*9+320*a^3*6^6*9^3+384*a*6^6*9^5)
2^5^6*(24*a^5*6^6*9+320*a^2*6^6*9^3+384*a*6^6*9^5)
2^5^6*2*a*6^3*(a^2+12*9^2)*4*6^3*9*(3*a^2+4*9^2)
2^5^6*4*a*6^3*(a^2+12*9^2)*2*6^3*9*(3*a^2+4*9^2)
2^5^6*2*a*6^3*(a^2+21*9^2)*4*6^3*9*(3*a^2+4*9^2)
]]></test_input>
<test_output><![CDATA[VXY
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛提高组 2005年NOIP全国联赛提高组]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <algorithm>
#include <string>
#include <sstream>
#include <cstring>
#include <stack>
using namespace std;

const int N = 27, MOD = 0x7fffffff;
long long Std_Value[N], v[N];
string s;
istringstream ss;

struct State
{
	long long v, c1, c2;
	char c3;
	
	State() {}
	State(long long V, long long C1, long long C2, char C3) {v = V; c1 = C1; c2 = C2; c3 = C3;}
} C;
stack<State> st[N];
long long Pow(long long a, int b)
{
	long long c = 1;
	while (b)
	{
		if (b & 1) c = c * a % MOD;
		a = a * a % MOD;
		b >>= 1;
	}
	return c;
}
void Calc()
{
	int i, c4;
	long long c1[N], c2[N] = {0};
	char c, c3[N];
	
	fill(c1, c1 + N, 1);
	fill(v, v + N, 0);
	fill(c3, c3 + N, '+');
	ss.str(s);
	while (ss >> c)
	{
		if (c == '^') ss >> c4;
		for (i = 0; i < N; i++)
			switch (c)
			{
				case '(': 
					st[i].push(State(v[i], c1[i], c2[i], c3[i]));
					v[i] = c2[i] = 0; c1[i] = 1; c3[i] = '+';
					break;
				case ')':
					C = st[i].top(); st[i].pop();
					if (c3[i] == '+') c2[i] = (v[i] + c1[i] * c2[i] % MOD) % MOD;
					else c2[i] = (v[i] - c1[i] * c2[i] % MOD) % MOD;
					c1[i] = C.c1; c3[i] = C.c3; v[i] = C.v;
					break;
				case '+':
				case '-':
					if (c3[i] == '+') v[i] = (v[i] + c1[i] * c2[i] % MOD) % MOD;
					else v[i] = (v[i] - c1[i] * c2[i] % MOD) % MOD;
					c1[i] = 1; c2[i] = 0; c3[i] = c; break;
				case '*': c1[i] = c1[i] * c2[i] % MOD; c2[i] = 0; break;
				case '^': c2[i] = Pow(c2[i], c4); break;
				case 'a': c2[i] = i; break;
				default: c2[i] = c2[i] * 10 + c - '0';
			}
	}
	for (i = 0; i < N; ++i)
		if (c3[i] == '+') v[i] = (v[i] + c1[i] * c2[i] % MOD) % MOD;
		else v[i] = (v[i] - c1[i] * c2[i] % MOD) % MOD;
	ss.clear();
}

int main()
{
	int n, i, j;
	bool OK;
	
	getline(cin, s);
	Calc();
	copy(v, v + N, Std_Value);
	getline(cin, s);
	ss.str(s);
	ss >> n;
	ss.clear();
	for (i = 0; i < n; ++i)
	{
		getline(cin, s);
		Calc();
		OK = true;
		for (j = 0; j < N; ++j)
			if ((Std_Value[j] - v[j]) % MOD) {OK = false; break;}
		if (OK) cout << (char)(i + 'A');
	}
	cout << endl;
	
	return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[var
  s:string;
  h:array[1..100] of int64;
  i,kk:longint;
  ans,n,base,m,p:int64;
function power(x:int64; y:longint):int64;
var
  i:longint;
begin
  x:=x mod maxlongint;
  power:=1;
  for i:=1 to y do power:=power*x mod maxlongint;
end;
function data(l,r:longint):int64;
var
  i:longint;
begin
  data:=0;
  for i:=l to r do data:=data*10+ord(s[i])-48;
end;
function find(l,r:longint):int64;
var
  i,min:longint;
begin
  min:=maxlongint;
  find:=0;
  for i:=r downto l do
    if h[i]<min then
    begin
      min:=h[i];
      find:=i;
    end;
end;
function opt(a,k,b:int64):int64;
begin
  case s[k] of
    '+':opt:=(a+b) mod maxlongint;
    '-':opt:=(a-b) mod maxlongint;
    '*':opt:=(a*b) mod maxlongint;
    '^':opt:=power(a,b) mod maxlongint;
  end;
end;
function work(l,r:longint):int64;
var
  a,b:int64;
  k:longint;
begin
  if s[l]='(' then inc(l);
  if s[r]=')' then dec(r);
  k:=find(l,r);
  if k=0 then exit(data(l,r));
  a:=work(l,k-1);
  b:=work(k+1,r);
  work:=opt(a,k,b);
end;
begin
  readln(s);
  p:=pos(' ',s);
  while p<>0 do
  begin
    delete(s,p,1);
    p:=pos(' ',s);
  end;
  n:=length(s);
  for i:=1 to n do
    if s[i]='a' then s[i]:='2';
  for i:=1 to n do h[i]:=maxlongint;
  base:=0;
  for i:=1 to n do
    case s[i] of
      '(':inc(base,3);
      ')':dec(base,3);
      '+','-':h[i]:=base+1;
      '*','/':h[i]:=base+2;
      '^':h[i]:=base+3;
    end;
  ans:=work(1,n) mod maxlongint;
  readln(m);
  for kk:=1 to m do
  begin
    readln(s);
    p:=pos(' ',s);
    while p<>0 do
    begin
      delete(s,p,1);
      p:=pos(' ',s);
    end;
    n:=length(s);
    for i:=1 to n do
      if s[i]='a' then s[i]:='2';
    for i:=1 to n do h[i]:=maxlongint;
    base:=0;
    for i:=1 to n do
      case s[i] of
        '(':inc(base,3);
        ')':dec(base,3);
        '+','-':h[i]:=base+1;
        '*','/':h[i]:=base+2;
        '^':h[i]:=base+3;
      end;
    if ans=work(1,n) mod maxlongint then write(chr(64+kk));
  end;
end.]]></solution>
	</item>
</fps>
