<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[ [ZJOI2012]波浪]]></title>
<time_limit unit="s"><![CDATA[6]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	阿米巴和小强是好朋友。
</p>
<p>
	阿米巴和小强在大海旁边看海水的波涛。小强第一次面对如此汹涌的海潮，他兴奋地叫个不停。而阿米巴则很淡定，他回想起曾经的那些日子，事业的起伏，情感的挫折……总之今天的风浪和曾经经历的那些风雨比起来，简直什么都不算。
</p>
<p>
	于是，这对好朋友不可避免地产生了分歧。为了论证自己的观点，小强建立了一个模型。他海面抽象成一个1到N的排列P[1…N]。定义波动强度等于相邻两项的差的绝对值的和，即：
</p>
<p>
	L = | P2 – P1 | + | P3 – P2 | + … + | PN – PN-1 |
给你一个N和M，问：随机一个1…N的排列，它的波动强度不小于M的概率有多大？
</p>
<p>
	答案请保留小数点后K位输出，四舍五入。
</p>
<h2>
	输入输出格式
</h2>
<strong>输入格式：</strong><br />
<p>
	<br />
</p>
<p>
	输入文件wavel.in的第一行包含三个整数N, M和K，分别表示排列的长度，波动强度，输出位数。
</p>
<p>
	<br />
</p>
<strong>输出格式：</strong><br />
<p>
	<br />
</p>
<p>
	输出文件wavel.out包含一个小数点后K位的实数。
</p>
<p>
	<br />
</p>
<h2>
	输入输出样例
</h2>
<div class="am-g">
	<div class="am-u-md-6 copy-region">
		<strong>输入样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>3 3 3</pre>
	</div>
	<div class="am-u-md-6 copy-region">
		<strong>输出样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>0.667</pre>
	</div>
</div>
<h2>
	说明
</h2>
<p>
	N = 3的排列有6个：123，132，213，231，312，321；他们的波动强度分别为2，3，3，3，3，2。所以，波动强度不小于3的概率是4/6，即0.667。
</p>
<p>
	你也可以通过下面的代码来验证这个概率：
</p>
<pre>int a[3]={0,1,2},s=0,n=3;
for (int i=0;i&lt;1000000;i++){ random_shuffle(a,a+n); int t=0; for (int j=0;j<n-1;j++) t+="abs(a[j+1]-a[j]);" if="" (t="">=3) s++;
}
printf("%.3f\n",s/1000000.0);</n-1;j++)></pre>
<p>
	【数据规模】
对于30%的数据，N ≤ 10。
</p>
<p>
	对于另外30%的数据，K ≤ 3。
</p>
<p>
	对于另外30%的数据，K ≤ 8。
</p>
<p>
	对于另外10%的数据，N ≤ 50。
</p>
<p>
	对于100%的数据，N ≤ 100，K ≤ 30，0 ≤ M ≤ 2147483647。
</p>
<div class="lg-article-sub am-g" id="sub">
</div>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[50 800 30
]]></test_input>
<test_output><![CDATA[0.679705552729533952728069958782
]]></test_output>
<test_input><![CDATA[100 3195 8
]]></test_input>
<test_output><![CDATA[0.74795244
]]></test_output>
<test_input><![CDATA[40 600 3
]]></test_input>
<test_output><![CDATA[0.098
]]></test_output>
<test_input><![CDATA[10 25 4
]]></test_input>
<test_output><![CDATA[0.9288
]]></test_output>
<test_input><![CDATA[30 300 8
]]></test_input>
<test_output><![CDATA[0.50704053
]]></test_output>
<test_input><![CDATA[40 620 8
]]></test_input>
<test_output><![CDATA[0.04429402
]]></test_output>
<test_input><![CDATA[100 3200 3
]]></test_input>
<test_output><![CDATA[0.740
]]></test_output>
<test_input><![CDATA[5 7 3
]]></test_input>
<test_output><![CDATA[0.833
]]></test_output>
<test_input><![CDATA[8 20 30
]]></test_input>
<test_output><![CDATA[0.643452380952380952380952380952
]]></test_output>
<test_input><![CDATA[25 200 3
]]></test_input>
<test_output><![CDATA[0.636
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[ZJOI2012 省选 NOIP ZJOI 高级]]></source>
		<solution language="C++"><![CDATA[#include <bits/stdc++.h>
#define N 110
#define MAX 4500
using namespace std;
typedef long long ll;
int i,j,k,n,m,x,y,t,q,la,no;
namespace dob {typedef double db;db f[2][9005][101][3];}
namespace fl {typedef __float128 db;db f[2][9005][101][3];}
template <class T> inline
void print2(T x,int k){
    for (i=2;i<=n;i++)x=x/(T)i;
    ll a=x;x-=a;int s[100],l,j=0;s[0]=0;
    while (a)s[++s[0]]=a%10,a/=10;if (!s[0])s[++s[0]]=0;l=s[0];
    for (i=1;i<=k+1;i++){x*=10;a=(int)x;x-=a;s[++s[0]]=a;}
    if (s[s[0]]]]><![CDATA[>=5)j=1;int p=s[0];
    while (j&&p){s[p-1]++;j=s[p-1]/10;s[p-1]%=10;p--;}
    if (j){for (i=s[0];i>1;i--)s[i]=s[i-1];s[1]=1;}
    putchar('0'+s[1]);if (k)putchar('.');for (i=2;i<=k+1;i++)putchar(s[i]+'0');
    return;
}
template <class T> inline
void solve(T f[][9005][101][3]){
    f[0][MAX-2*1][1][0]=1;f[0][MAX-1][1][1]=2;f[0][MAX][1][2]=1;no=0;la=1;
    for (int i=2;i<=n;i++){
        no=1-no,la=1-la;
        memset(f[no],0,sizeof f[no]);
        for (int j=0;j<=MAX*2;j++)
            for (int k=1;k<=n-1;k++){
                if (f[la][j][k][0]){
                    if (j>=2*i)f[no][j-2*i][k+1][0]+=f[la][j][k][0]*(k+1);
                    if (j+2*i<=MAX*2)f[no][j+2*i][k-1][0]+=f[la][j][k][0]*(k-1);
                    f[no][j][k][0]+=f[la][j][k][0]*k*2;
                    if (j+i<=MAX*2)f[no][j+i][k][1]+=f[la][j][k][0]*2;
                    if (j>=i)f[no][j-i][k+1][1]+=f[la][j][k][0]*2;
                }
                if (f[la][j][k][1]){
                    if (j>=2*i)f[no][j-2*i][k+1][1]+=f[la][j][k][1]*k;
                    if (j+2*i<=MAX*2)f[no][j+2*i][k-1][1]+=f[la][j][k][1]*(k-1);
                    f[no][j][k][1]+=f[la][j][k][1]*(2*k-1);
                    if (j+i<=MAX*2)f[no][j+i][k][2]+=f[la][j][k][1];
                    if (j>=i)f[no][j-i][k+1][2]+=f[la][j][k][1];
                }
                if (f[la][j][k][2]){
                    if (j+i*2<=MAX*2)f[no][j+i*2][k-1][2]+=f[la][j][k][2]*(k-1);
                    if (j>=2*i)f[no][j-i*2][k+1][2]+=f[la][j][k][2]*(k-1);
                    f[no][j][k][2]+=2*f[la][j][k][2]*(k-1);
                }
            }
    }
    T ans=0;
    for (int i=m+MAX;i<=MAX*2;i++)ans+=(T)f[no][i][1][2];
    print2(ans,q);
}
int main(){
    scanf("%d%d%d",&n,&m,&q);if (q<=8)solve(dob::f);else solve(fl::f);
    return 0;
}
]]></solution>
	</item>
</fps>
