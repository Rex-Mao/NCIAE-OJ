<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[明明的随机数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[125]]></memory_limit>

<description><![CDATA[<p>
	明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[每组输入有2行，第1行为1个正整数，表示所生成的随机数的个数N，第2行有N个用空格隔开的正整数，为所产生的随机数。<br />
<div>
	<br />
</div>]]></input> 
<output><![CDATA[<p>
	每组输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[10
20 40 32 67 40 20 89 300 400 15]]></sample_input>
<sample_output><![CDATA[8
15 20 32 40 67 89 300 400]]></sample_output>
  <test_input><![CDATA[90
7 2 315 437 447 231 189 301 407 8 407 84 341 408 525 41 322 220 40 321 302 457 215 315 437 447 231 189 301 407 89 301 407 515 40 321 120 40 321 679 678 676 659 67 409 201 899 801 407 185 5 497 447 241 89 301 407 515 40 321 120 490 321 677 40 321 67 40 20 891 301 407 15 499 440 240 89 301 407 515 40 321 67 410 20 89 301 407 15 498

]]></test_input>
<test_output><![CDATA[48
2 5 7 8 15 20 40 41 67 84 89 120 185 189 201 215 220 231 240 241 301 302 315 321 322 341 407 408 409 410 437 440 447 457 490 497 498 499 515 525 659 676 677 678 679 801 891 899

]]></test_output>
<test_input><![CDATA[60
89 301 407 515 40 321 120 40 821 675 673 671 670 67 40 20 891 301 407 15 151 97 4 241 893 301 407 515 840 311 150 420 321 677 40 321 67 40 20 81 303 407 15 499 440 240 89 301 407 515 40 321 67 410 20 89 301 407 15 499

]]></test_input>
<test_output><![CDATA[32
4 15 20 40 67 81 89 97 120 150 151 240 241 301 303 311 321 407 410 420 440 499 515 670 671 673 675 677 821 840 891 893

]]></test_output>
<test_input><![CDATA[20
20 40 321 677 40 20 89 301 407 515 40 321 67 40 20 89 301 407 15 499

]]></test_input>
<test_output><![CDATA[11
15 20 40 67 89 301 321 407 499 515 677
]]></test_output>
<test_input><![CDATA[40
5 491 440 240 89 301 407 515 403 321 120 40 321 677 402 321 67 40 20 89 301 407 15 492 440 240 89 301 407 515 40 321 67 410 20 9 301 407 15 499

]]></test_input>
<test_output><![CDATA[21
5 9 15 20 40 67 89 120 240 301 321 402 403 407 410 440 491 492 499 515 677
]]></test_output>
<test_input><![CDATA[80
407 84 341 408 525 41 322 220 40 321 302 45 215 315 437 447 231 189 304 404 8 301 407 515 40 321 120 40 321 617 637 679 779 767 40 20 89 301 707 815 15 497 447 241 89 301 407 515 40 321 120 40 321 677 40 321 67 40 20 89 301 407 15 499 440 240 89 301 407 515 40 321 67 410 20 89 301 407 15 498

]]></test_input>
<test_output><![CDATA[43
8 15 20 40 41 45 67 84 89 120 189 215 220 231 240 241 301 302 304 315 321 322 341 404 407 408 410 437 440 447 497 498 499 515 525 617 637 677 679 707 767 779 815

]]></test_output>
<test_input><![CDATA[8
20 40 321 67 40 40 89 15

]]></test_input>
<test_output><![CDATA[6
15 20 40 67 89 321

]]></test_output>
<test_input><![CDATA[70
302 457 215 315 437 447 231 189 301 407 89 306 407 515 40 321 120 40 321 617 627 637 679 67 430 230 8 303 408 125 15 497 447 241 89 301 402 515 40 321 120 40 321 677 40 327 67 40 20 89 301 407 15 499 440 240 89 301 407 515 40 321 67 410 20 89 301 407 15 498

]]></test_input>
<test_output><![CDATA[39
8 15 20 40 67 89 120 125 189 215 230 231 240 241 301 302 303 306 315 321 327 402 407 408 410 430 437 440 447 457 497 498 499 515 617 627 637 677 679

]]></test_output>
<test_input><![CDATA[50
607 420 321 67 40 20 89 301 407 135 15 4 447 241 89 301 407 515 410 321 120 40 321 667 400 321 67 40 209 89 301 407 15 499 440 240 89 301 407 515 40 321 637 410 20 8 301 407 15 49

]]></test_input>
<test_output><![CDATA[26
4 8 15 20 40 49 67 89 120 135 209 240 241 301 321 400 407 410 420 440 447 499 515 607 637 667

]]></test_output>
<test_input><![CDATA[30
120 40 321 677 40 321 67 40 20 89 301 407 15 499 440 240 89 301 407 515 40 321 67 40 20 89 301 407 15 499

]]></test_input>
<test_output><![CDATA[14
15 20 40 67 89 120 240 301 321 407 440 499 515 677
]]></test_output>
<test_input><![CDATA[10
20 40 321 67 40 20 89 301 407 15

]]></test_input>
<test_output><![CDATA[8
15 20 40 67 89 301 321 407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[NOIP全国联赛普及组-2006年NOIP全国联赛普及组]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
void main()
{
	int a[1001]={0},i,n,t,r=0,s=0;
	scanf("%d",&n);
	for (i=0;i<n;i++)
	{
		scanf("%d",&t);
		if (!a[t]) s++;
		a[t]=1;
	}
	printf("%d\n",s);
	for (i=0;i<1001;i++)
 	if (a[i]) 
	{
		printf("%d",i);
		r++;
		if (r!=s) printf(" ");
	}
}
]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>
#include<algorithm>
using namespace std;
int main()
{
	int n;
	cin >> n;
	int a[100];
	int b;
	int j;
	for (j = 0; n--;){
		cin >> b;
		int i;
		for (i = 0; i < j; i++){
			if (b == a[i])
				break;
		}
			if (i == j){
				a[j] = b;
				j++;
		}
	}
	sort(a, a + j);
	cout << j << endl;
	for (int i = 0; i < j;i++)
	if (i)
		cout << " " << a[i];
	else
		cout << a[i];
}]]></solution>
			<solution language="Pascal"><![CDATA[var n,i,x,j:longint;a,b:array[1..1000]of longint;
begin
 readln(n);
 for i:=1 to n do
  begin
   read(x);
   a[x]:=1
  end;
 for i:=1 to 1000 do if a[i]=1 then begin inc(j);b[j]:=i;end;
 writeln(j);
 for i:=1 to j-1 do write(b[i],' ');write(b[j])
end.]]></solution>
			<solution language="Java"><![CDATA[import java.util.ArrayList;
import java.util.HashSet;
import java.util.Scanner;
import java.util.TreeSet;

public class Main {
	public static void main(String[] args) {
		TreeSet<Integer> set  = new  TreeSet<>();
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		while(n>0){
			int r = s.nextInt();
			set.add(r);
			n--;
		}
		Integer num =null;
		System.out.println(set.size());
		while((num = set.pollFirst())!=null){
			System.out.print(num+" ");
		}
	}
}
]]></solution>
	</item>
</fps>
