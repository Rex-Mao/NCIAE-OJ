<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[ [ZJOI2010]排列计数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	称一个1,2,...,N的排列P1,P2...,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，...N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值
</p>
<h2>
	输入输出格式
</h2>
<strong>输入格式：</strong><br />
<p>
	<br />
</p>
<p>
	输入文件的第一行包含两个整数 n和p，含义如上所述。
</p>
<p>
	<br />
</p>
<strong>输出格式：</strong><br />
<p>
	<br />
</p>
<p>
	输出文件中仅包含一个整数，表示计算1,2,⋯<span>⋯</span>的排列中， Magic排列的个数模 p的值。
</p>
<p>
	<br />
</p>
<h2>
	输入输出样例
</h2>
<div class="am-g">
	<div class="am-u-md-6 copy-region">
		<strong>输入样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>20 23 </pre>
	</div>
	<div class="am-u-md-6 copy-region">
		<strong>输出样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>16
</pre>
	</div>
</div>
<h2>
	说明
</h2>
<p>
	100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。
</p>
<div class="lg-article-sub am-g" id="sub">
</div>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[10 94093591
]]></test_input>
<test_output><![CDATA[3360
]]></test_output>
<test_input><![CDATA[18380 97130141
]]></test_input>
<test_output><![CDATA[37661545
]]></test_output>
<test_input><![CDATA[932385 2006009
]]></test_input>
<test_output><![CDATA[1062704
]]></test_output>
<test_input><![CDATA[6334 97596781
]]></test_input>
<test_output><![CDATA[38678874
]]></test_output>
<test_input><![CDATA[26954 98403341
]]></test_input>
<test_output><![CDATA[26231912
]]></test_output>
<test_input><![CDATA[4 95665237
]]></test_input>
<test_output><![CDATA[3
]]></test_output>
<test_input><![CDATA[159677 1059217
]]></test_input>
<test_output><![CDATA[638727
]]></test_output>
<test_input><![CDATA[12357 97367069
]]></test_input>
<test_output><![CDATA[1649210
]]></test_output>
<test_input><![CDATA[9 95836177
]]></test_input>
<test_output><![CDATA[896
]]></test_output>
<test_input><![CDATA[995423 1707577
]]></test_input>
<test_output><![CDATA[701801
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[ZJOI2010 ZJOI 省选 高级]]></source>
		<solution language="C++"><![CDATA[


#include <cstdio>
#include <cstring>

typedef long long llint;

int n, p;
llint F[1000005];
llint ways[1000005];

llint extended_gcd( llint a, llint &x, llint b, llint &y )
{
	if( b == 0 ) {
		x = 1;
		y = 0;
		return a;
	}

	/*
	 * b * y' + (a - (a/b) * b) * x' == d
	 * x = x'
	 * y = y' - (a / b) * x'
	 */

	llint d = extended_gcd(b, y, a%b, x);
	y -= (a/b) * x;

	return d;
}

llint inv( llint x )
{
	llint y;
	llint q;
	llint d = extended_gcd(x, y, p, q);

	return (y%p + p) % p;
}

llint binom( int n, int m )
{
	llint ret = F[n];

	ret = (ret*inv(F[m])) % p;
	ret = (ret*inv(F[n-m])) % p;

	return ret;
}

llint Ways( int n )
{
	llint &ret = ways[n];
	if( ret >= 0 ) return ret;

	int sz = 1;
	while( sz*2 + 1 <= n )
		sz = sz*2 + 1;

	int l;
	int r;
	if( sz + (sz+1)/2 >= n ) {
		r = sz/2;
		l = n-1 - r;
	} else {
		l = sz/2 + (sz+1)/2;
		r = n-1 - l;
	}

	ret = binom(n-1, l);
	ret = (ret*Ways(l)) % p;
	ret = (ret*Ways(r)) % p;

	return ret;
}

int main( void )
{
//	freopen( "perm.in", "r", stdin );
//	freopen( "perm.out", "w", stdout );

	scanf( "%d %d", &n, &p );

	*F = 1;
	for( int i = 1; i <= n; ++i )
		F[i] = (F[i-1]*i) % p;

	memset(ways, -1, sizeof(ways));
	ways[0] = ways[1] = 1;

	printf( "%lld\n", Ways(n) );

	return 0;
}

]]></solution>
	</item>
</fps>
