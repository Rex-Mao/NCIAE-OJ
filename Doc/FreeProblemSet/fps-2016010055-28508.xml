<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[抛硬币]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	有一枚硬币，抛出正面H的概率为a/b，抛出反面T的概率为1-a/b。现在TT小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为H，反面记为T，于是她得到了一个抛硬币序列HTHHT…。她突然想到一个问题：在抛出正面和反面概率都是1/2的情况下，要使得抛出的序列出现目标序列HT，期望要抛多少次。然而经过1秒的思考以后她发现，若第一次抛出的是T，那么还需要期望抛出HT的次数，如果第一次抛出的是H，则期望只需要抛出T的次数，而期望抛出T的次数显然是2。她设抛出HT的期望次数是x，则得到了方程：
</p>
<p>
	x=1+(1/2*x+1/2*2)&nbsp;
</p>
<p>
	解得x=4，所以抛出HT的期望次数是4次。
</p>
<p>
	她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为HT时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。
</p>
<h2>
	输入输出格式
</h2>
<strong>输入格式：</strong><br />
<p>
	<br />
</p>
<p>
	第一行两个数a,b。意义如题目描述。
</p>
<p>
	接下来1行一个只包含’H’和’T’的字符串S。表示要抛出的目标序列。
</p>
<p>
	<br />
</p>
<strong>输出格式：</strong><br />
<p>
	<br />
</p>
<p>
	输出仅一行p/q，其中p和q均为正整数且互质，表示抛出目标序列S所需要的期望步数。
</p>
<p>
	注意，若q为1时，不省略/1。
</p>
<p>
	<br />
</p>
<h2>
	输入输出样例
</h2>
<div class="am-g">
	<div class="am-u-md-6 copy-region">
		<strong>输入样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>1 2
HT</pre>
	</div>
	<div class="am-u-md-6 copy-region">
		<strong>输出样例#1：</strong> <a class="am-badge am-radius lg-bg-orange sample-copy">复制</a> 
<pre>4/1</pre>
	</div>
</div>
<h2>
	说明
</h2>
<p>
	50%数据a=1,b=2,|s|&lt;=20 100%数据a=b,b=100,|s|&lt;=1000
</p>
<div class="lg-article-sub am-g" id="sub">
</div>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1 2
HHT
]]></test_input>
<test_output><![CDATA[8/1]]></test_output>
<test_input><![CDATA[1 2
HTHHHTHHHTHHHTH]]></test_input>
<test_output><![CDATA[34954/1]]></test_output>
<test_input><![CDATA[32 61
HTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTH]]></test_input>
<test_output><![CDATA[11731344788729960709105884664462811525657346767924079440270272564262422028955849490496301045951259597427881037740087854077649482088151354439615786175720284057119310731504526122376510809340505357945949176275484529523422565488408630289361825888773145417068527366462782839788718559269406436409740532814127651363680245750450145826566205692367907849818404915663873777513626753878735110264923854611018517447898515839421414838915868964876006935388173082014568619139609295151702079147010404721967875087892667676344417538044971322897076499124336611583543471518465659715378120243977714248631446599090151972913333365218999445635210117472830591989479082930555451166394423700736898125085/1928664319178121358460048882224149655206242231834768628088307053140945866893737413869491149173972824929699999941192652270190010492344689864865649256367162811256388380939109829546205510335866712591055908664349181169603890333586553586662199593471150397289058231986827343968628803937172980871782560938014941850085117842427316277570269974123784928972120573176121467191238501042303788024846906733019845987637870521358201322877471411370735744338567633255222589850851620634964231781168690904106004032404436318866593573970502338530024073920180401059675636501195408801792]]></test_output>
<test_input><![CDATA[1 2
TTT]]></test_input>
<test_output><![CDATA[14/1]]></test_output>
<test_input><![CDATA[51 97
THHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTH]]></test_input>
<test_output><![CDATA[8275878080155413201729121082442050486724284209892588717935293508527861568700533756958611228259503600673879270522607023018082935737442789537816386780016625166664590000518639125443188929858197816562584540090301836418997965577536859881537141148059401810933252546078463904673810611827235675709922724383281638339003188218166914211530782935799993138409196363543112378001999759486537291896923386066112878016994292584191301656060182453571226493963371532618159564071577441/7508486041968369258552659808561282836147874455514263080909034650827031254758105365103822354342697913597260315292835217744696028538202734632674461744217730400300702597889145794142494366105306187482440836666943287653705798406103259637445264939604576070517748956409974621010140941987416882932951003524928183587958949694587408265018330702656981788176694362651430673552362788891490674053525176057856]]></test_output>
<test_input><![CDATA[1 2
HHTHHTHH
]]></test_input>
<test_output><![CDATA[294/1]]></test_output>
<test_input><![CDATA[3 7
HTHHHTHHHTHHHTH
]]></test_input>
<test_output><![CDATA[4971256500763/45349632]]></test_output>
<test_input><![CDATA[17 49
THHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTH]]></test_input>
<test_output><![CDATA[2675784431388739822993777148329665962641654515844310952361965977761465228382211913615004847749461289369209621627439139590667303133145882257908626554033/70760344509177294824204722168787113878467368358886648361327447687146197168794354738404561443065675761129872388503109632]]></test_output>
<test_input><![CDATA[6 28
HTHHTHHTHHTHTHHTHHTHHTHTHHTHHTHHTHTHHTHHTHHT
]]></test_input>
<test_output><![CDATA[268928607937953502940113597465987377322124999847076/1051182433450463752648165940721]]></test_output>
<test_input><![CDATA[37 63
THHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTHHTHTHHTHTHHTHHTHTHHTH]]></test_input>
<test_output><![CDATA[5483326016502428012259119208259827569778843735065237713382016087085300223858313635547168520908148477827161839763496722273240904877111952471450344195282017878889989799170545233125273769805411443678952883017478732257147757461339470313721890066335373502258110247911410834284416194649149587747005979998960546577923691084158221003517391992040509036046614551959433879410717975614511197401666818518254154505177949615552198839804854300231824669362131538331364259849836509888024894534171563118252645551696814975977982574830909074915434369800148174980042722819914146944620321184273468247351637932117629559402484894101581906817365145949917406536166492433608692792421533825365845637199198520813283991235883172946295703242830864368605083742025688125439574490543482178899633631327989777496874775858850169028625717793109728967791972134358604551773594862054410273563769275309745042479630749283460617897339364559155987297397365346898110533445121615697773865407391529209364109699793074246758832026894822256293167063086634832840923919566842048097791190250853190911278272365267959579809707835425826709139336243908700289392038578686678122501096761633679818433345615707906569716444410301033650586980494319861264953418946627739608177159085808062058350919009776943600155858034867903/182401625860714342024136070831588787937214448891127526544130180998194541623840170875343947994628608869054130250443069701592243971999564377367515402640401609069692902666522378066530727900189846173919060085798432817108110683315664733861670471193784170811657093523906678276733797331406206327569813350892118310409197859242400107113874365505721862731478058956800153711028402655898954549836477548304705585285989015422176345402620099865962958596903290336551691391954934176216833525971782322511379578879520221588849102067922032673251413453104534851736991230057729432586662528080829127666233529110023909850748187768038329532203756673383421367193179386070300631930001117853305368883390985033196849932013812315821724446561719584468864313267978872213841516481393235652645790161325012744827214002177513135652193189720733162930457435987834679386688627856212281211663101694821710418058070937819869775713774317595016029406620668426422286527489609105123280203457023189250048893456996503328009130914136726785886502121176487082099503421102904926040593968572900272331875680256]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[ZJOI2013 NOIP 省选 高级]]></source>
		<solution language="C++"><![CDATA[#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <cmath>
#include <cstdio>
#include <vector>
#include <string>
#include <cctype>
#include <bitset>
#include <cstring>
#include <cstdlib>
#include <utility>
#include <iostream>
#include <algorithm>
#define REP(i,a,b) for(int i=(a);i<=(b);i++)
#define PER(i,a,b) for(int i=(a);i>=(b);i--)
#define RVC(i,S) for(int i=0;i<(S).size();i++)
#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)
using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
      
template<class T> inline
void read(T& num) {
    bool start=false,neg=false;
    char c;
    num=0;
    while((c=getchar())!=EOF) {
        if(c=='-') start=neg=true;
        else if(c>='0' && c<='9') {
            start=true;
            num=num*10+c-'0';
        } else if(start) break;
    }
    if(neg) num=-num;
}
/*============ Header Template ============*/
 
 
const int BASE=(int)(1e8);
 
struct node {
    int num[1005],top;
     
    node(int x=0) {*this=x;}
 
    int& operator[] (int k) {return num[k];}
 
    inline node operator = (int x) {
        top=0;
        if(!x) num[++top]=0;
        else for(;x;num[++top]=x%BASE,x/=BASE);
        return *this;
    }
 
    inline void modify() {
        int i=1,x=0;
        for(;x || i<=top;i++) {
            if(i>top) num[i]=0;
            x+=num[i]; num[i]=x%BASE;x/=BASE;
        }
        top=max(top,i-1);
        for(;top>1 && !num[top];top--);
    }
 
    inline void print() {printf("%d",num[top]);PER(i,top-1,1) printf("%08d",num[i]);}
};
 
inline node operator + (node a,node b) {
    node c;
    c.top=max(a.top,b.top);
    REP(i,1,c.top) {
        if(i>a.top) a[i]=0;
        if(i>b.top) b[i]=0;
        c[i]=a[i]+b[i];
    }
    c.modify();return c;
}
 
inline node operator - (node a,node b) {
    node c;int x=0;
    c.top=max(a.top,b.top);
    REP(i,1,c.top) {
        if(i>a.top) a[i]=0;
        if(i>b.top) b[i]=0;
        a[i]-=x;x=0;
        if(a[i]<b[i]) x=1;
        c[i]=x*BASE+a[i]-b[i];
    }
    c.modify();return c;
}
 
LL tmp[1005];
inline node operator * (node a,node b) {
    node c;
    c.top=a.top+b.top-1;
    REP(i,1,c.top) tmp[i]=0;
    REP(i,1,a.top) REP(j,1,b.top) tmp[i+j-1]+=1LL*a[i]*b[j];
    LL g=0;
    for(int i=1;i<=c.top || g;i++) {
        if(i>c.top) tmp[i]=0;
        g+=tmp[i];c[i]=g%BASE;g/=BASE;
        c.top=max(c.top,i);
    } return c;
}
 
inline node operator / (node a,int b) {
    node c;c.top=1;
    LL x=0;
    PER(i,a.top,1) {
        x=x*BASE+a[i];
        if(x<b) continue;
        c[i]=x/b;x%=b;
        c.top=max(c.top,i);
    } return c;
}
 
inline int operator % (node a,int b) {
    int c=0;
    PER(i,a.top,1) c=(1LL*c*BASE+a[i])%b;
    return c;
}
 
struct fnode {
    node x,y;
 
    fnode(int _x=0,int _y=1) {
        int d=__gcd(_x,_y);_x/=d;_y/=d;x=_x;y=_y;
    }
 
    fnode(node _x,node _y):x(_x),y(_y) {}
 
    inline void chk() {
        REP(i,2,100) while(x%i==0 && y%i==0) x=x/i,y=y/i;
    }
 
    inline void print() {x.print();putchar('/');y.print();}
};
 
inline fnode operator + (fnode a,fnode b) {
    return fnode(a.x*b.y+a.y*b.x,a.y*b.y);
}
 
inline fnode operator - (fnode a,fnode b) {
    return fnode(a.x*b.y-a.y*b.x,a.y*b.y);
}
 
inline fnode operator * (fnode a,fnode b) {
    return fnode(a.x*b.x,a.y*b.y);
}
 
inline fnode operator / (fnode a,fnode b) {
    return fnode(a.x*b.y,a.y*b.x);
}
 
char s[1005];
int f[1005],g[1005];
fnode K[1005],C[1005];
 
int main() {
    int p,q;
    read(p);read(q);
    scanf("%s",s+1);
    int n=strlen(s+1);
    for(int i=2,j=0;i<=n;i++) {
        while(j && s[i]!=s[j+1]) j=f[j];
        if(s[i]==s[j+1]) j++;f[i]=j;
    }
    REP(i,1,n) {
        g[i]=i;
        while(g[i] && s[i+1]==s[g[i]+1]) g[i]=f[g[i]];
        if(s[i+1]!=s[g[i]+1]) g[i]++;
    }
    fnode H=fnode(p,q),T=fnode(q-p,q),I=fnode(1,1);
    K[0]=fnode(1,1);C[0]=fnode(0,1);
    REP(i,1,n) {
        fnode A=H,B=T;
        if(s[i]=='T') swap(A,B);
        K[i]=(K[i-1]-B*K[g[i-1]])/A;K[i].chk();
        C[i]=(C[i-1]-B*C[g[i-1]]+I)/A;C[i].chk();
    } fnode res=C[n]/K[n];res.print();putchar('\n');
    return 0;
}]]></solution>
	</item>
</fps>
